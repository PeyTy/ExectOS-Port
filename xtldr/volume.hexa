// Hexa 2024 from clang 15.0.3
/// This routine closes an EFI volume handle.
/// 
/// @param VolumeHandle
///        Specifies a handle of opened volume.
/// 
/// @return This routine returns status code.
/// 
/// @since XT 1.0
fun blCloseVolume(volumeHandle PEFI_HANDLE) {
	let lIPGuid = new ByValue<EFI_GUID>()

	if volumeHandle != (0 as! PVOID) {
		return efiSystemTable.BootServices.CloseProtocol(volumeHandle, lIPGuid, efiImageHandle, (0 as! PVOID))

	}

	return (9223372036854775808 & 0)
}

/// Discovers and enumerates a block devices available to EFI system.
/// 
/// @return This routine returns a status code.
/// 
/// @since XT 1.0
fun blEnumerateBlockDevices() {
	let lastNode = new ByValue<PEFI_DEVICE_PATH_PROTOCOL>()

	let parentNode = new ByValue<PEFI_BLOCK_DEVICE_DATA>()

	let blockDeviceData = new ByValue<PEFI_BLOCK_DEVICE_DATA>()

	let blockDevice = new ByValue<PEFI_BLOCK_DEVICE>()

	let blockDevices = new ByValue<LIST_ENTRY>()

	let listEntry = new ByValue<PLIST_ENTRY>()

	var status EFI_STATUS
	let acpiDevice = new ByValue<PEFI_ACPI_HID_DEVICE_PATH>()

	let hDPath = new ByValue<PEFI_HARDDRIVE_DEVICE_PATH>()

	let media = new ByValue<PEFI_BLOCK_IO_MEDIA>()

	let partitionGuid = new ByValue<PEFI_GUID>()

	var driveNumber ULONG
	var partitionNumber ULONG
	var driveType USHORT
	var cDCount ULONG = 0
	var fDCount ULONG = 0
	var hDCount ULONG = 0
	var rDCount ULONG = 0
	rtlInitializeListHead(blockDevices)
	rtlInitializeListHead(efiBlockDevices)
	status = blpDiscoverEfiBlockDevices(blockDevices)
	if status != (9223372036854775808 & 0) {
		blDebugPrint("ERROR: Failed to discover EFI block devices (Status Code: 0x%zX)\n", status)
		return status

	}

	listEntry = BlockDevices.Flink
	while listEntry != blockDevices {
		blockDeviceData = (((listEntry) as! Char * - ???? resolve OffsetOfExpr) as! EFI_BLOCK_DEVICE_DATA *)
		status = blpFindLastBlockDeviceNode(blockDeviceData.DevicePath, lastNode)
		if status != (9223372036854775808 & 0) {
			blDebugPrint("WARNING: Block device last node not found\n")
			listEntry = listEntry.Flink
			??? CompoundStmt ContinueStmt

		}

		driveType = 0
		if lastNode.Type == 2 and lastNode.SubType == 1 {
			acpiDevice = lastNode as! PEFI_ACPI_HID_DEVICE_PATH
			if acpiDevice.HID == 100942288 or acpiDevice.HID == 117457360 or acpiDevice.HID == 117522897 {
				media = blockDeviceData.BlockIo.Media
				driveType = 2
				driveNumber = ++fDCount
				partitionNumber = 0
				blDebugPrint("Found Floppy Disk (DiskNumber: %lu, MediaPresent: %u, RO: %u)\n", driveNumber, media.MediaPresent, media.ReadOnly)

			}


		} else {
			??? CompoundStmt CompoundStmt

		}

		if driveType != 0 {
			status = blAllocateMemoryPool(???? resolve UnaryExprOrTypeTraitExpr, blockDevice as! PVOID *)
			if status != (9223372036854775808 & 0) {
				blDebugPrint("ERROR: Failed to allocate memory pool for block device (Status Code: 0x%zX)\n", status)
				return (9223372036854775808 | 9)

			}

			blockDevice.DevicePath = blpDuplicateDevicePath(blockDeviceData.DevicePath)
			blockDevice.DriveType = driveType
			blockDevice.DriveNumber = driveNumber
			blockDevice.PartitionNumber = partitionNumber
			blockDevice.PartitionGuid = partitionGuid
			rtlInsertTailList(efiBlockDevices, blockDevice.ListEntry)

		}

		listEntry = listEntry.Flink

	}

	return (9223372036854775808 & 0)
}

/// Finds an EFI device path for a specified path on a given file system.
/// 
/// @param FsHandle
///        The handle of the corresponding file system.
/// 
/// @param FileSystemPath
///        Specifies a path on the corresponding file system.
/// 
/// @param DevicePath
///        Specifies a pointer to the memory area, where found device path will be stored.
/// 
/// @return This routine returns a status code.
/// 
/// @since XT 1.0
fun blFindVolumeDevicePath(fsHandle PEFI_DEVICE_PATH_PROTOCOL, fileSystemPath Const PWCHAR, devicePath PEFI_DEVICE_PATH_PROTOCOL *) {
	var status EFI_STATUS
	var fsPathLength SIZE_T
	var devicePathLength SIZE_T = 0
	let filePath = new ByValue<PEFI_FILEPATH_DEVICE_PATH>()

	let endDevicePath = new ByValue<PEFI_DEVICE_PATH_PROTOCOL>()

	let devicePathHandle = new ByValue<PEFI_DEVICE_PATH_PROTOCOL>()

	devicePathHandle = fsHandle
	while tRUE {
		if *devicePathHandle.Length as! PUSHORT == 0 {
			return (9223372036854775808 | 14)

		}

		if devicePathHandle.Type == 127 {
			??? CompoundStmt BreakStmt

		}

		??? CompoundStmt CompoundAssignOperator
		devicePathHandle = (devicePathHandle as! PUCHAR + *devicePathHandle.Length as! PUSHORT) as! PEFI_DEVICE_PATH_PROTOCOL

	}

	fsPathLength = rtlWideStringLength(fileSystemPath, 0) * ???? resolve UnaryExprOrTypeTraitExpr
	status = blAllocateMemoryPool(fsPathLength + devicePathLength + ???? resolve UnaryExprOrTypeTraitExpr, devicePath as! PVOID *)
	if status != (9223372036854775808 & 0) {
		return status

	}

	rtlCopyMemory(*devicePath, fsHandle, devicePathLength)
	filePath = (*devicePath as! PUCHAR + devicePathLength) as! PEFI_FILEPATH_DEVICE_PATH
	filePath.Header.Type = 4
	filePath.Header.SubType = 4
	???? resolve ArraySubscriptExpr = fsPathLength as! UCHAR + ???? resolve OffsetOfExpr + ???? resolve UnaryExprOrTypeTraitExpr
	???? resolve ArraySubscriptExpr = ???? resolve ArraySubscriptExpr >> 8
	rtlCopyMemory(filePath.PathName, fileSystemPath, fsPathLength + ???? resolve UnaryExprOrTypeTraitExpr)
	endDevicePath = ???? resolve ArraySubscriptExpr as! PEFI_DEVICE_PATH_PROTOCOL
	endDevicePath.Type = 127
	endDevicePath.SubType = 255
	???? resolve ArraySubscriptExpr = ???? resolve UnaryExprOrTypeTraitExpr
	???? resolve ArraySubscriptExpr = 0
	return (9223372036854775808 & 0)
}

/// Creates a copy of the system path with EFI standard directory separators.
/// 
/// @param SystemPath
///        Supplies a pointer to the system path.
/// 
/// @param EfiPath
///        Supplies a pointer to the memory area, where EFI path will be stored.
/// 
/// @return This routine returns a status code.
/// 
/// @since XT 1.0
fun blGetEfiPath(systemPath PWCHAR, efiPath PWCHAR *) {
	var index SIZE_T
	var pathLength SIZE_T
	var status EFI_STATUS
	pathLength = rtlWideStringLength(systemPath, 0)
	status = blAllocateMemoryPool(???? resolve UnaryExprOrTypeTraitExpr * (pathLength + 1), efiPath as! PVOID *)
	if status != (9223372036854775808 & 0) {
		blDebugPrint("ERROR: Memory allocation failure (Status Code: 0x%zX)\n", status)
		return (9223372036854775808 | 9)

	}

	rtlCopyMemory(*efiPath, systemPath, ???? resolve UnaryExprOrTypeTraitExpr * (pathLength + 1))
	??? CompoundStmt ForStmt
	return (9223372036854775808 & 0)
}

/// Finds a volume device path based on the specified ARC name or UUID.
/// 
/// @param SystemPath
///        An input string containing ARC/UUID path.
/// 
/// @param DevicePath
///        Supplies a pointer to memory region where device path will be stored.
/// 
/// @param Path
///        Supplies a pointer to the memory area, where path on device will be saved.
/// 
/// @return This routine returns a status code.
/// 
/// @since XT 1.0
fun blGetVolumeDevicePath(systemPath PWCHAR, devicePath PEFI_DEVICE_PATH_PROTOCOL *, arcName PWCHAR *, path PWCHAR *) {
	let device = new ByValue<PEFI_BLOCK_DEVICE>()

	var driveType USHORT
	var driveNumber ULONG
	var partNumber ULONG
	var volume PWCHAR
	var pathLength ULONG
	let listEntry = new ByValue<PLIST_ENTRY>()

	var status EFI_STATUS
	*devicePath = (0 as! PVOID)
	volume = systemPath
	while *volume != ???? resolve CharacterLiteral and *volume != ???? resolve CharacterLiteral and *volume != ???? resolve CharacterLiteral {
		??? CompoundStmt UnaryOperator

	}

	pathLength = volume - systemPath
	if pathLength == 0 {
		*path = systemPath
		return (9223372036854775808 | 14)

	}

	if ???? resolve ArraySubscriptExpr == ???? resolve CharacterLiteral {
		if pathLength == 38 {
			blDebugPrint("WARNING: EFI/GPT GUID in system path is not supported\n")
			return (9223372036854775808 | 3)

		} else {
			??? CompoundStmt CompoundStmt
			??? CompoundStmt CompoundStmt

		}


	} else {
		status = blpDissectVolumeArcPath(systemPath, arcName, path, driveType, driveNumber, partNumber)

	}

	if status != (9223372036854775808 & 0) {
		blDebugPrint("ERROR: Failed to parse system path: '%s' (Status Code: 0x%zX)\n", systemPath, status)
		return status

	}

	listEntry = EfiBlockDevices.Flink
	while listEntry != efiBlockDevices {
		device = (((listEntry) as! Char * - ???? resolve OffsetOfExpr) as! EFI_BLOCK_DEVICE *)
		if (device.DriveType == driveType and device.DriveNumber == driveNumber and device.PartitionNumber == partNumber) {
			*devicePath = device.DevicePath
			??? CompoundStmt BreakStmt

		}

		listEntry = listEntry.Flink

	}

	if *devicePath == (0 as! PVOID) {
		blDebugPrint("ERROR: Volume (DriveType: %u, DriveNumber: %lu, PartNumber: %lu) not found\n", driveType, driveNumber, partNumber)
		return (9223372036854775808 | 14)

	}

	return (9223372036854775808 & 0)
}

/// This routine opens an EFI volume and corresponding filesystem.
/// 
/// @param DevicePath
///        Specifies a device path of the volume to open. If not specifies, uses image protocol by default.
/// 
/// @param DiskHandle
///        The handle of the opened disk volume.
/// 
/// @param FsHandle
///        The handle of the opened file system.
/// 
/// @return This routine returns status code.
/// 
/// @since XT 1.0
fun blOpenVolume(devicePath PEFI_DEVICE_PATH_PROTOCOL, diskHandle PEFI_HANDLE, fsHandle PEFI_FILE_HANDLE *) {
	let sFSGuid = new ByValue<EFI_GUID>()

	let lIPGuid = new ByValue<EFI_GUID>()

	let fileSystemProtocol = new ByValue<PEFI_SIMPLE_FILE_SYSTEM_PROTOCOL>()

	let imageProtocol = new ByValue<PEFI_LOADED_IMAGE_PROTOCOL>()

	var status EFI_STATUS
	if devicePath != (0 as! PVOID) {
		status = efiSystemTable.BootServices.LocateDevicePath(sFSGuid, devicePath, diskHandle)
		if status != (9223372036854775808 & 0) {
			return status

		}


	} else {
		status = efiSystemTable.BootServices.OpenProtocol(efiImageHandle, lIPGuid, imageProtocol as! PVOID *, efiImageHandle, (0 as! PVOID), 1)
		if status != (9223372036854775808 & 0) {
			return status

		}

		*diskHandle = imageProtocol.DeviceHandle

	}

	status = efiSystemTable.BootServices.OpenProtocol(*diskHandle, sFSGuid, fileSystemProtocol as! PVOID *, efiImageHandle, (0 as! PVOID), 1)
	if status != (9223372036854775808 & 0) {
		blCloseVolume(*diskHandle)
		return status

	}

	status = fileSystemProtocol.OpenVolume(fileSystemProtocol, fsHandle)
	if status != (9223372036854775808 & 0) {
		blCloseVolume(*diskHandle)
		return status

	}

	return (9223372036854775808 & 0)
}

/// Reads data from the file.
/// 
/// @param DirHandle
///        Supplies a handle of the opened filesystem directory.
/// 
/// @param FileName
///        Supplies the name of the file to read.
/// 
/// @param FileData
///        Provides a buffer to store the data read from the file.
/// 
/// @param FileSize
///        Provides a pointer to the variable to store a size of the buffer.
/// 
/// @return This routine returns status code.
/// 
/// @since XT 1.0
fun blReadFile(dirHandle PEFI_FILE_HANDLE, fileName Const PWCHAR, fileData PVOID *, fileSize PSIZE_T) {
	let fileInfoGuid = new ByValue<EFI_GUID>()

	var address EFI_PHYSICAL_ADDRESS
	let fileHandle = new ByValue<PEFI_FILE_HANDLE>()

	let fileInfo = new ByValue<PEFI_FILE_INFO>()

	var status EFI_STATUS
	var readSize UINT_PTR
	var pages SIZE_T
	status = dirHandle.Open(dirHandle, fileHandle, fileName, 1, 1 | 2 | 4)
	if status != (9223372036854775808 & 0) {
		return status

	}

	readSize = ???? resolve UnaryExprOrTypeTraitExpr + 32
	status = blAllocateMemoryPool(readSize, fileInfo as! PVOID *)
	if status != (9223372036854775808 & 0) {
		fileHandle.Close(fileHandle)
		return status

	}

	fileHandle.GetInfo(fileHandle, fileInfoGuid, readSize, fileInfo)
	if status == (9223372036854775808 | 5) {
		blFreeMemoryPool(fileInfo)
		status = blAllocateMemoryPool(readSize, fileInfo as! PVOID *)
		if status != (9223372036854775808 & 0) {
			fileHandle.Close(fileHandle)
			return status

		}

		status = fileHandle.GetInfo(fileHandle, fileInfoGuid, readSize, fileInfo)

	}

	if status != (9223372036854775808 & 0) {
		fileHandle.Close(fileHandle)
		blFreeMemoryPool(fileInfo)
		return status

	}

	*fileSize = fileInfo.FileSize
	pages = (((fileInfo.FileSize) >> 12) + (???? resolve ConditionalOperator))
	status = blAllocateMemoryPages(pages, address)
	if status != (9223372036854775808 & 0) {
		fileHandle.Close(fileHandle)
		blFreeMemoryPool(fileInfo)
		return status

	}

	readSize = pages * 4096
	*fileData = address as! UINT_PTR as! PCHAR
	rtlZeroMemory(*fileData, readSize)
	status = fileHandle.Read(fileHandle, readSize, *fileData)
	if status != (9223372036854775808 & 0) {
		fileHandle.Close(fileHandle)
		blFreeMemoryPool(fileInfo)
		blFreeMemoryPages(pages, *fileData as! UINT_PTR as! EFI_PHYSICAL_ADDRESS)
		return status

	}

	fileHandle.Close(fileHandle)
	blFreeMemoryPool(fileInfo)
	return (9223372036854775808 & 0)
}

/// Gets a list of block devices from an EFI enabled BIOS.
/// 
/// @param BlockDevices
///        Supplies a pointer to a variable to receive a list of EFI block devices.
/// 
/// @return This routine returns a status code.
/// 
/// @since XT 1.0
fun blpDiscoverEfiBlockDevices(blockDevices PLIST_ENTRY) {
	let devicePathGuid = new ByValue<EFI_GUID>()

	let ioGuid = new ByValue<EFI_GUID>()

	let devicePath = new ByValue<PEFI_DEVICE_PATH_PROTOCOL>()

	let blockDevice = new ByValue<PEFI_BLOCK_DEVICE_DATA>()

	var handlesCount UINT_PTR
	var index UINT_PTR
	var handles PEFI_HANDLE = (0 as! PVOID)
	let io = new ByValue<PEFI_BLOCK_IO_PROTOCOL>()

	var status EFI_STATUS
	status = blLocateProtocolHandles(handles, handlesCount, ioGuid)
	if status != (9223372036854775808 & 0) {
		blDebugPrint("ERROR: Failed to locate block devices handles (Status Code: 0x%zX)\n", status)
		return status

	}

	??? CompoundStmt ForStmt
	blFreeMemoryPool(handles)
	return (9223372036854775808 & 0)
}

/// Dissects a specified ARC name and provides detailed information about corresponding device and on disk path.
/// 
/// @param SystemPath
///        Supplies an input ARC path.
/// 
/// @param Path
///        Specifies a pointer to variable, where on disk path will be saved.
/// 
/// @param DriveType
///        Supplies a pointer to the variable that receives a drive type.
/// 
/// @param DriveNumber
///        Supplies a pointer to the variable that receives a drive number.
/// 
/// @param PartNumber
///        Supplies a pointer to the variable that receives a parition number if applicable, otherwise stores 0 (zero).
/// 
/// @return This routine returns a status code.
/// 
/// @since XT 1.0
fun blpDissectVolumeArcPath(systemPath PWCHAR, arcName PWCHAR *, path PWCHAR *, driveType PUSHORT, driveNumber PULONG, partNumber PULONG) {
	var arcPath PWCHAR
	var localArcName PWCHAR
	var arcLength ULONG = 0
	*driveType = 0
	*driveNumber = 0
	*partNumber = 0
	if rtlCompareWideStringInsensitive(systemPath, "ramdisk(0)", 0) == 0 {
		arcLength = 10
		*driveType = 4

	} else {
		??? CompoundStmt CompoundStmt
		??? CompoundStmt CompoundStmt

	}

	if path {
		*path = systemPath + arcLength

	}

	if arcName {
		blAllocateMemoryPool(arcLength * ???? resolve UnaryExprOrTypeTraitExpr, localArcName as! PVOID *)
		rtlCopyMemory(localArcName, systemPath, arcLength * ???? resolve UnaryExprOrTypeTraitExpr)
		???? resolve ArraySubscriptExpr = ???? resolve CharacterLiteral
		*arcName = localArcName

	}

	return (9223372036854775808 & 0)
}

/// This routine duplicates a device path object.
/// 
/// @param DevicePath
///        An input device path that is going to be clonned.
/// 
/// @return Returns a duplicate of input device path.
/// 
/// @since XT 1.0
fun blpDuplicateDevicePath(devicePath PEFI_DEVICE_PATH_PROTOCOL) {
	let devicePathNode = new ByValue<PEFI_DEVICE_PATH_PROTOCOL>()

	let devicePathClone = new ByValue<PEFI_DEVICE_PATH_PROTOCOL>()

	var status EFI_STATUS
	var length UINT = 0
	devicePathNode = devicePath
	while tRUE {
		??? CompoundStmt CompoundAssignOperator
		if devicePathNode.Type == 127 {
			??? CompoundStmt BreakStmt

		}

		devicePathNode = (devicePathNode as! PUCHAR + *devicePath.Length as! PUSHORT) as! PEFI_DEVICE_PATH_PROTOCOL

	}

	if length == 0 {
		return (0 as! PVOID)

	}

	status = blAllocateMemoryPool(length, devicePathClone as! PVOID *)
	if status != (9223372036854775808 & 0) {
		blDebugPrint("ERROR: Failed to allocate memory pool for device path duplicate (Status Code: 0x%zX)\n", status)
		return (0 as! PVOID)

	}

	rtlCopyMemory(devicePathClone, devicePath, length)
	return devicePathClone
}

/// Attempts to find a last node of the EFI block device.
/// 
/// @param DevicePath
///        An input device path.
/// 
/// @param LastNode
///        A pointer to the buffer where last node will be stored.
/// 
/// @return This routine returns a status code.
/// 
/// @since XT 1.0
fun blpFindLastBlockDeviceNode(devicePath PEFI_DEVICE_PATH_PROTOCOL, lastNode PEFI_DEVICE_PATH_PROTOCOL *) {
	let endNode = new ByValue<PEFI_DEVICE_PATH_PROTOCOL>()

	let nextNode = new ByValue<PEFI_DEVICE_PATH_PROTOCOL>()

	if devicePath.Type == 127 {
		lastNode = (0 as! PVOID)
		return (9223372036854775808 | 2)

	}

	endNode = devicePath
	while endNode.Type != 127 {
		nextNode = endNode
		endNode = (endNode as! PUCHAR + *endNode.Length as! PUSHORT) as! PEFI_DEVICE_PATH_PROTOCOL

	}

	*lastNode = nextNode
	return (9223372036854775808 & 0)
}

/// This routine attempts to find a parent device of the provided block device.
/// 
/// @param BlockDevice
///        A linked list of discovered block devices.
/// 
/// @param ChildNode
///        Block device that is looking for a parent device.
/// 
/// @param ParentNode
///        A pointer to memory region where pointer to the parent node will be provided.
/// 
/// @return This routine returns TRUE if parent node has been found, or FALSE otherwise.
/// 
/// @since XT 1.0
fun blpFindParentBlockDevice(blockDevices PLIST_ENTRY, childNode PEFI_BLOCK_DEVICE_DATA, parentNode PEFI_BLOCK_DEVICE_DATA) {
	let childDevicePath = new ByValue<PEFI_DEVICE_PATH_PROTOCOL>()

	let parentDevicePath = new ByValue<PEFI_DEVICE_PATH_PROTOCOL>()

	let blockDeviceData = new ByValue<PEFI_BLOCK_DEVICE_DATA>()

	var childLength UINT
	var parentLength UINT
	let listEntry = new ByValue<PLIST_ENTRY>()

	listEntry = blockDevices.Flink
	while listEntry != blockDevices {
		blockDeviceData = (((listEntry) as! Char * - ???? resolve OffsetOfExpr) as! EFI_BLOCK_DEVICE_DATA *)
		childDevicePath = childNode.DevicePath
		parentDevicePath = blockDeviceData.DevicePath
		while tRUE {
			if parentDevicePath.Type == 127 {
				parentNode = blockDeviceData
				return tRUE

			}

			childLength = *childDevicePath.Length as! PUSHORT
			parentLength = *parentDevicePath.Length as! PUSHORT
			if childLength != parentLength {
				??? CompoundStmt BreakStmt

			}

			childDevicePath = (childDevicePath as! PUCHAR + childLength) as! PEFI_DEVICE_PATH_PROTOCOL
			parentDevicePath = (parentDevicePath as! PUCHAR + parentLength) as! PEFI_DEVICE_PATH_PROTOCOL

		}

		listEntry = listEntry.Flink

	}

	return fALSE
}
