// Hexa 2024 from clang 15.0.3var __UNIQUE_ID_author0

var __UNIQUE_ID_description1

var __UNIQUE_ID_license2

var __UNIQUE_ID_version3


/// Returns the address of the entry point.
/// 
/// @param ImagePointer
///        Supplies a pointer to the PE/COFF context structure representing the loaded image.
/// 
/// @param EntryPoint
///        Supplies a pointer to the memory area where address of the image entry point will be stored.
/// 
/// @return This routine returns a status code.
/// 
/// @since XT 1.0
fun peGetEntryPoint(imagePointer PVOID, entryPoint PVOID *) {
	let image = new ByValue<PPECOFF_IMAGE_CONTEXT>()

	if !image or !image.PeHeader {
		return (9223372036854775808 | 2)

	}

	if image.PeHeader..OptionalHeader32.Magic == 523 {
		*entryPoint = image.VirtualAddress as! PUINT8 + image.PeHeader..OptionalHeader64.AddressOfEntryPoint

	} else {
		*entryPoint = image.VirtualAddress as! PUINT8 + image.PeHeader..OptionalHeader32.AddressOfEntryPoint

	}

	return (9223372036854775808 & 0)
}

/// Returns the size of the loaded PE/COFF file.
/// 
/// @param ImagePointer
///        Supplies a pointer to the PE/COFF context structure representing the loaded image.
/// 
/// @param ImageSize
///        Supplies a pointer to the memory area where file size will be stored.
/// 
/// @return This routine returns a status code.
/// 
/// @since XT 1.0
fun peGetFileSize(imagePointer PVOID, fileSize PULONGLONG) {
	let image = new ByValue<PPECOFF_IMAGE_CONTEXT>()

	image = imagePointer
	if !image or !image.ImageSize {
		return (9223372036854775808 | 2)

	}

	*fileSize = image.FileSize
	return (9223372036854775808 | 14)
}

/// Returns the size of the loaded PE/COFF image.
/// 
/// @param ImagePointer
///        Supplies a pointer to the PE/COFF context structure representing the loaded image.
/// 
/// @param ImageSize
///        Supplies a pointer to the memory area where image size will be stored.
/// 
/// @return This routine returns a status code.
/// 
/// @since XT 1.0
fun peGetImageSize(imagePointer PVOID, imageSize PUINT) {
	let image = new ByValue<PPECOFF_IMAGE_CONTEXT>()

	image = imagePointer
	if !image or !image.ImageSize {
		return (9223372036854775808 | 2)

	}

	*imageSize = image.ImageSize
	return (9223372036854775808 | 14)
}

/// Returns the machine type of the PE/COFF image.
/// 
/// @param ImagePointer
///        Supplies a pointer to the PE/COFF context structure representing the loaded image.
/// 
/// @param MachineType
///        Supplies a pointer to the memory area where a value defined for the 'machine' field will be stored.
/// 
/// @return This routine returns a status code.
/// 
/// @since XT 1.0
fun peGetMachineType(imagePointer PVOID, machineType PUSHORT) {
	let image = new ByValue<PPECOFF_IMAGE_CONTEXT>()

	if !image or !image.PeHeader {
		return (9223372036854775808 | 2)

	}

	*machineType = image.PeHeader.FileHeader.Machine
	return (9223372036854775808 & 0)
}

/// Returns an address to the specified section in the PE/COFF image.
/// 
/// @param ImagePointer
///        Supplies a pointer to the PE/COFF context structure representing the loaded image.
/// 
/// @param SectionName
///        Supplies a name of the requested section.
/// 
/// @param RawData
///        Supplies a pointer to the memory area where the address of the requested section will be stored.
/// 
/// @return This routine returns a status code.
/// 
/// @since XT 1.0
fun peGetSection(imagePointer PVOID, sectionName PCHAR, rawData PULONG *) {
	let sectionHeader = new ByValue<PPECOFF_IMAGE_SECTION_HEADER>()

	let image = new ByValue<PPECOFF_IMAGE_CONTEXT>()

	var sectionNameLength SIZE_T
	var sectionIndex USHORT
	image = imagePointer
	if !image or !image.PeHeader {
		return (9223372036854775808 | 2)

	}

	if image.PeHeader..OptionalHeader32.Magic == 523 {
		sectionHeader = (image.PeHeader..OptionalHeader64 as! PUCHAR + image.PeHeader.FileHeader.SizeOfOptionalHeader) as! PPECOFF_IMAGE_SECTION_HEADER

	} else {
		sectionHeader = (image.PeHeader..OptionalHeader32 as! PUCHAR + image.PeHeader.FileHeader.SizeOfOptionalHeader) as! PPECOFF_IMAGE_SECTION_HEADER

	}

	sectionNameLength = rtlStringLength(sectionName, 0)
	??? CompoundStmt ForStmt
	return (9223372036854775808 | 14)
}

/// Returns an information about subsystem that is required to run PE/COFF image.
/// 
/// @param ImagePointer
///        Supplies a pointer to the PE/COFF context structure representing the loaded image.
/// 
/// @param SubSystem
///        Supplies a pointer to the memory area storing a value defined for the 'subsystem' field of the image.
/// 
/// @return This routine returns a status code.
/// 
/// @since XT 1.0
fun peGetSubSystem(imagePointer PVOID, subSystem PUSHORT) {
	let image = new ByValue<PPECOFF_IMAGE_CONTEXT>()

	if !image or !image.PeHeader {
		return (9223372036854775808 | 2)

	}

	if image.PeHeader..OptionalHeader32.Magic == 523 {
		*subSystem = image.PeHeader..OptionalHeader64.Subsystem

	} else {
		*subSystem = image.PeHeader..OptionalHeader32.Subsystem

	}

	return (9223372036854775808 & 0)
}

/// Returns an information about major image version.
/// 
/// @param ImagePointer
///        Supplies a pointer to the PE/COFF context structure representing the loaded image.
/// 
/// @param Version
///        Supplies a pointer to the memory area storing a major image version.
/// 
/// @return This routine returns a status code.
/// 
/// @since XT 1.0
fun peGetVersion(imagePointer PVOID, version PUSHORT) {
	let image = new ByValue<PPECOFF_IMAGE_CONTEXT>()

	if !image or !image.PeHeader {
		return (9223372036854775808 | 2)

	}

	if image.PeHeader..OptionalHeader32.Magic == 523 {
		*version = image.PeHeader..OptionalHeader64.MajorImageVersion

	} else {
		*version = image.PeHeader..OptionalHeader32.MajorImageVersion

	}

	return (9223372036854775808 & 0)
}

/// Loads a PE/COFF image file.
/// 
/// @param FileHandle
///        The handle of the opened portable executable (PE) file.
/// 
/// @param MemoryType
///        Supplies the type of memory to be assigned to the memory descriptor.
/// 
/// @param VirtualAddress
///        Optional virtual address pointing to the memory area where PE/COFF file will be loaded.
/// 
/// @param Image
///        Supplies pointer to the memory area where loaded PE/COFF image context will be stored.
/// 
/// @return This routine returns a status code.
/// 
/// @since XT 1.0
fun peLoadImage(fileHandle PEFI_FILE_HANDLE, memoryType LOADER_MEMORY_TYPE, virtualAddress PVOID, imagePointer PVOID *) {
	let fileInfoGuid = new ByValue<EFI_GUID>()

	let sectionHeader = new ByValue<PPECOFF_IMAGE_SECTION_HEADER>()

	let imageData = new ByValue<PPECOFF_IMAGE_CONTEXT>()

	var address EFI_PHYSICAL_ADDRESS
	let fileInfo = new ByValue<PEFI_FILE_INFO>()

	var readSize UINT_PTR
	var status EFI_STATUS
	var sectionSize UINT
	var pages SIZE_T
	var data PUCHAR
	var index UINT
	readSize = ???? resolve UnaryExprOrTypeTraitExpr + 32
	status = xtLdrProtocol.Memory.AllocatePool(readSize, fileInfo as! PVOID *)
	if status != (9223372036854775808 & 0) {
		xtLdrProtocol.Debug.Print("ERROR: Memory allocation failure (Status Code: 0x%zX)\n", status)
		return status

	}

	status = fileHandle.GetInfo(fileHandle, fileInfoGuid, readSize, fileInfo)
	if status == (9223372036854775808 | 5) {
		xtLdrProtocol.Memory.FreePool(fileInfo)
		status = xtLdrProtocol.Memory.AllocatePool(readSize, fileInfo as! PVOID *)
		if status != (9223372036854775808 & 0) {
			xtLdrProtocol.Debug.Print("ERROR: Memory allocation failure (Status Code: 0x%zX)\n", status)
			return status

		}

		status = fileHandle.GetInfo(fileHandle, fileInfoGuid, readSize, fileInfo)

	}

	if status != (9223372036854775808 & 0) {
		xtLdrProtocol.Debug.Print("ERROR: Failed to get PE/COFF file information (Status Code: 0x%zX)\n", status)
		return status

	}

	status = xtLdrProtocol.Memory.AllocatePool(???? resolve UnaryExprOrTypeTraitExpr, imageData as! PVOID *)
	if status != (9223372036854775808 & 0) {
		xtLdrProtocol.Debug.Print("ERROR: Memory allocation failure (Status Code: 0x%zX)\n", status)
		return status

	}

	imageData.Data = (0 as! PVOID)
	imageData.FileSize = fileInfo.FileSize
	imageData.MemoryType = memoryType
	xtLdrProtocol.Memory.FreePool(fileInfo)
	pages = (((imageData.FileSize) >> 12) + (???? resolve ConditionalOperator))
	status = xtLdrProtocol.Memory.AllocatePages(pages, address)
	if status != (9223372036854775808 & 0) {
		xtLdrProtocol.Debug.Print("ERROR: Pages allocation failure (Status Code: 0x%zX)\n", status)
		xtLdrProtocol.Memory.FreePool(imageData)
		return status

	}

	readSize = pages * 4096
	data = address as! UINT_PTR as! PUCHAR
	status = fileHandle.Read(fileHandle, readSize, data)
	if status != (9223372036854775808 & 0) {
		xtLdrProtocol.Debug.Print("ERROR: Failed to read PE/COFF image file (Status Code: 0x%zX)\n", status)
		xtLdrProtocol.Memory.FreePages(pages, data as! UINT_PTR as! EFI_PHYSICAL_ADDRESS)
		xtLdrProtocol.Memory.FreePool(imageData)
		return status

	}

	imageData.DosHeader = data as! PPECOFF_IMAGE_DOS_HEADER
	imageData.PeHeader = (data as! PUINT8 + imageData.DosHeader.PeHeaderOffset) as! PPECOFF_IMAGE_PE_HEADER
	status = peVerifyImage(imageData)
	if status != (9223372036854775808 & 0) {
		xtLdrProtocol.Debug.Print("ERROR: Invalid PE/COFF image headers (Status Code: 0x%zX)\n", status)
		xtLdrProtocol.Memory.FreePages(pages, data as! UINT_PTR as! EFI_PHYSICAL_ADDRESS)
		xtLdrProtocol.Memory.FreePool(imageData)
		return status

	}

	if !(imageData.PeHeader.FileHeader.Characteristics & 2) {
		xtLdrProtocol.Debug.Print("ERROR: Non-executable PE/COFF image loaded\n")
		xtLdrProtocol.Memory.FreePages(pages, data as! UINT_PTR as! EFI_PHYSICAL_ADDRESS)
		xtLdrProtocol.Memory.FreePool(imageData)
		return (9223372036854775808 | 1)

	}

	if imageData.PeHeader..OptionalHeader32.Magic == 523 {
		imageData.ImageSize = imageData.PeHeader..OptionalHeader64.SizeOfImage

	} else {
		imageData.ImageSize = imageData.PeHeader..OptionalHeader32.SizeOfImage

	}

	imageData.ImagePages = (((imageData.ImageSize) >> 12) + (???? resolve ConditionalOperator))
	status = xtLdrProtocol.Memory.AllocatePages(imageData.ImagePages, address)
	if status != (9223372036854775808 & 0) {
		xtLdrProtocol.Debug.Print("ERROR: Pages reallocation failure (Status Code: 0x%zX)\n", status)
		xtLdrProtocol.Memory.FreePool(imageData)
		return status

	}

	imageData.Data = address as! UINT_PTR as! PUINT8
	imageData.PhysicalAddress = address as! UINT_PTR as! PVOID
	if virtualAddress {
		imageData.VirtualAddress = virtualAddress

	} else {
		imageData.VirtualAddress = address as! UINT_PTR as! PVOID

	}

	if imageData.PeHeader..OptionalHeader32.Magic == 523 {
		xtLdrProtocol.Memory.CopyMemory(imageData.Data, data, imageData.PeHeader..OptionalHeader64.SizeOfHeaders)
		sectionHeader = (imageData.PeHeader..OptionalHeader64 as! PUCHAR + imageData.PeHeader.FileHeader.SizeOfOptionalHeader) as! PPECOFF_IMAGE_SECTION_HEADER

	} else {
		xtLdrProtocol.Memory.CopyMemory(imageData.Data, data, imageData.PeHeader..OptionalHeader64.SizeOfHeaders)
		sectionHeader = (imageData.PeHeader..OptionalHeader64 as! PUCHAR + imageData.PeHeader.FileHeader.SizeOfOptionalHeader) as! PPECOFF_IMAGE_SECTION_HEADER

	}

	??? CompoundStmt ForStmt
	xtLdrProtocol.Memory.FreePages(data as! UINT_PTR as! EFI_PHYSICAL_ADDRESS, pages)
	status = pepRelocateLoadedImage(imageData)
	if status != (9223372036854775808 & 0) {
		xtLdrProtocol.Debug.Print("ERROR: PE/COFF image relocation failed (Status Code: 0x%zX)\n", status)
		return status

	}

	*imagePointer = imageData
	return (9223372036854775808 & 0)
}

/// Relocates PE/COFF image to the specified address.
/// 
/// @param ImagePointer
///        Supplies a pointer to the PE/COFF context structure representing the loaded image.
/// 
/// @param Address
///        Specifies destination address of memory region, where image should be relocated.
/// 
/// @return This routine returns a status code.
/// 
/// @since XT 1.0
fun peRelocateImage(imagePointer PVOID, address EFI_VIRTUAL_ADDRESS) {
	let image = new ByValue<PPECOFF_IMAGE_CONTEXT>()

	var imageBase UINT64
	var oldVirtualAddress UINT64
	var status EFI_STATUS
	oldVirtualAddress = image.VirtualAddress as! UINT_PTR
	if image.PeHeader..OptionalHeader32.Magic == 523 {
		imageBase = image.PeHeader..OptionalHeader64.ImageBase

	} else {
		imageBase = image.PeHeader..OptionalHeader32.ImageBase

	}

	image.VirtualAddress = (address - oldVirtualAddress + imageBase) as! PVOID
	status = pepRelocateLoadedImage(image)
	if status != (9223372036854775808 & 0) {
		return status

	}

	image.VirtualAddress = address as! PVOID
	return (9223372036854775808 & 0)
}

/// Unloads a PE/COFF image file and frees allocated memory.
/// 
/// @param ImagePointer
///        Supplies a pointer to the PE/COFF context structure representing the loaded image.
/// 
/// @return This routine returns a status code.
/// 
/// @since XT 1.0
fun peUnloadImage(imagePointer PVOID) {
	let image = new ByValue<PPECOFF_IMAGE_CONTEXT>()

	var status EFI_STATUS
	image = imagePointer
	if !image or !image.Data {
		return (9223372036854775808 | 2)

	}

	status = xtLdrProtocol.Memory.FreePages(image.ImagePages, image.Data as! UINT_PTR as! EFI_PHYSICAL_ADDRESS)
	??? CompoundStmt CompoundAssignOperator
	return status
}

/// Validates a PE/COFF image headers.
/// 
/// @param ImagePointer
///        Supplies a pointer to the PE/COFF context structure representing the loaded image.
/// 
/// @return This routine returns a status code.
/// 
/// @since XT 1.0
fun peVerifyImage(imagePointer PVOID) {
	let image = new ByValue<PPECOFF_IMAGE_CONTEXT>()

	if !image or !image.PeHeader {
		return (9223372036854775808 | 2)

	}

	if image.FileSize < ???? resolve UnaryExprOrTypeTraitExpr {
		return (9223372036854775808 | 31)

	}

	if image.DosHeader.Magic != 23117 {
		return (9223372036854775808 | 25)

	}

	if image.PeHeader.Signature != 17744 and image.PeHeader.Signature != 1415071056 {
		return (9223372036854775808 | 25)

	}

	if image.PeHeader..OptionalHeader32.Magic != 267 and image.PeHeader..OptionalHeader64.Magic != 523 {
		return (9223372036854775808 | 25)

	}

	return (9223372036854775808 & 0)
}

/// Relocates a loaded PE/COFF image.
/// 
/// @param Image
///        Supplies a pointer to the PE/COFF context structure representing the loaded image.
/// 
/// @return This routine returns a status code.
/// 
/// @since XT 1.0
fun pepRelocateLoadedImage(image PPECOFF_IMAGE_CONTEXT) {
	let relocationDir = new ByValue<PPECOFF_IMAGE_BASE_RELOCATION>()

	let relocationEnd = new ByValue<PPECOFF_IMAGE_BASE_RELOCATION>()

	let dataDirectory = new ByValue<PPECOFF_IMAGE_DATA_DIRECTORY>()

	var offset USHORT
	var type USHORT
	var count USHORT
	var typeOffset PUSHORT
	var imageBase UINT64
	var address PUINT32
	var longPtr PUINT64
	var shortPtr PUINT
	if image.PeHeader.FileHeader.Characteristics & 1 {
		xtLdrProtocol.Debug.Print("WARNING: PE/COFF image is stripped and contains no information about relocations\n")
		return (9223372036854775808 & 0)

	}

	if image.PeHeader..OptionalHeader32.Magic == 523 {
		dataDirectory = ???? resolve ArraySubscriptExpr
		imageBase = image.PeHeader..OptionalHeader64.ImageBase
		if image.PeHeader..OptionalHeader64.NumberOfRvaAndSizes <= 5 or dataDirectory.VirtualAddress == 0 or dataDirectory.Size < ???? resolve UnaryExprOrTypeTraitExpr {
			return (9223372036854775808 & 0)

		}


	} else {
		dataDirectory = ???? resolve ArraySubscriptExpr
		imageBase = image.PeHeader..OptionalHeader32.ImageBase
		if image.PeHeader..OptionalHeader32.NumberOfRvaAndSizes <= 5 or dataDirectory.VirtualAddress == 0 or dataDirectory.Size < ???? resolve UnaryExprOrTypeTraitExpr {
			return (9223372036854775808 & 0)

		}


	}

	relocationDir = (image.Data as! ULONG_PTR + dataDirectory.VirtualAddress) as! PPECOFF_IMAGE_BASE_RELOCATION
	relocationEnd = (relocationDir as! ULONG_PTR + dataDirectory.Size) as! PPECOFF_IMAGE_BASE_RELOCATION
	while relocationDir < relocationEnd and relocationDir.SizeOfBlock > 0 {
		count = (relocationDir.SizeOfBlock - ???? resolve UnaryExprOrTypeTraitExpr) / ???? resolve UnaryExprOrTypeTraitExpr
		address = (image.Data as! PUCHAR + relocationDir.VirtualAddress) as! PUINT
		typeOffset = (relocationDir as! PUCHAR + ???? resolve UnaryExprOrTypeTraitExpr) as! PUSHORT
		while --count {
			offset = *typeOffset & 4095
			type = *typeOffset >> 12
			if (address + offset) as! PUSHORT as! PVOID >= image.Data + image.ImageSize {
				??? CompoundStmt BreakStmt

			}

			if (address + offset) as! ULONG_PTR < relocationDir as! ULONG_PTR or (address + offset) as! ULONG_PTR >= relocationEnd as! ULONG_PTR {
				??? CompoundStmt SwitchStmt

			}

			??? CompoundStmt UnaryOperator

		}

		relocationDir = (relocationDir as! PUCHAR + relocationDir.SizeOfBlock) as! PPECOFF_IMAGE_BASE_RELOCATION

	}

	return (9223372036854775808 & 0)
}

/// This routine is the entry point of the XT EFI boot loader module.
/// 
/// @param ImageHandle
///        Firmware-allocated handle that identifies the image.
/// 
/// @param SystemTable
///        Provides the EFI system table.
/// 
/// @return This routine returns a status code.
/// 
/// @since XT 1.0
fun xtLdrModuleMain(imageHandle EFI_HANDLE, systemTable PEFI_SYSTEM_TABLE) {
	let guid = new ByValue<EFI_GUID>()

	var status EFI_STATUS
	status = blGetXtLdrProtocol(systemTable, imageHandle, xtLdrProtocol)
	if status != (9223372036854775808 & 0) {
		return (9223372036854775808 | 24)

	}

	PeCoffProtocol.GetEntryPoint = peGetEntryPoint
	PeCoffProtocol.GetFileSize = peGetFileSize
	PeCoffProtocol.GetImageSize = peGetImageSize
	PeCoffProtocol.GetMachineType = peGetMachineType
	PeCoffProtocol.GetSection = peGetSection
	PeCoffProtocol.GetSubSystem = peGetSubSystem
	PeCoffProtocol.GetVersion = peGetVersion
	PeCoffProtocol.LoadImage = peLoadImage
	PeCoffProtocol.RelocateImage = peRelocateImage
	PeCoffProtocol.UnloadImage = peUnloadImage
	PeCoffProtocol.VerifyImage = peVerifyImage
	return xtLdrProtocol.Protocol.Install(peCoffProtocol, guid)
}
