// Hexa 2024 from clang 15.0.3var __UNIQUE_ID_author0

var __UNIQUE_ID_description1

var __UNIQUE_ID_license2

var __UNIQUE_ID_version3


/// Chainloads another boot loader.
/// 
/// @param Parameters
///        Input parameters with detailed system configuration.
/// 
/// @return This routine returns a status code.
/// 
/// @since XT 1.0
fun chBootSystem(parameters PXTBL_BOOT_PARAMETERS) {
	let lIPGuid = new ByValue<EFI_GUID>()

	var memoryDevicePath EFI_MEMMAP_DEVICE_PATH[2]
	let loadedImage = new ByValue<PEFI_LOADED_IMAGE_PROTOCOL>()

	var diskHandle EFI_HANDLE
	var loaderHandle EFI_HANDLE
	let fsHandle = new ByValue<PEFI_FILE_HANDLE>()

	let bootDir = new ByValue<PEFI_FILE_HANDLE>()

	var status EFI_STATUS
	var loaderSize SIZE_T
	var loaderData PVOID
	if parameters.KernelFile == (0 as! PVOID) {
		xtLdrProtocol.Debug.Print("ERROR: No EFI image filename provided\n")
		return (9223372036854775808 | 2)

	}

	status = xtLdrProtocol.Disk.OpenVolume((0 as! PVOID), diskHandle, fsHandle)
	if status != (9223372036854775808 & 0) {
		xtLdrProtocol.Debug.Print("ERROR: Unable to open boot volume (Status Code: 0x%zX)\n", status)
		return status

	}

	status = fsHandle.Open(fsHandle, bootDir, parameters.EfiPath, 1, 0)
	fsHandle.Close(fsHandle)
	if status != (9223372036854775808 & 0) {
		xtLdrProtocol.Debug.Print("ERROR: Unable to open system boot directory (Status Code: 0x%zX)\n", status)
		xtLdrProtocol.Disk.CloseVolume(diskHandle)
		return status

	}

	status = xtLdrProtocol.Disk.ReadFile(bootDir, parameters.KernelFile, loaderData, loaderSize)
	bootDir.Close(bootDir)
	xtLdrProtocol.Disk.CloseVolume(diskHandle)
	???? resolve ArraySubscriptExpr = ???? resolve UnaryExprOrTypeTraitExpr
	???? resolve ArraySubscriptExpr = ???? resolve UnaryExprOrTypeTraitExpr >> 8
	???? resolve ArraySubscriptExpr.Header.Type = 1
	???? resolve ArraySubscriptExpr.Header.SubType = 3
	???? resolve ArraySubscriptExpr.MemoryType = efiLoaderData
	???? resolve ArraySubscriptExpr.StartingAddress = loaderData as! UINT_PTR
	???? resolve ArraySubscriptExpr.EndingAddress = loaderData as! UINT_PTR + loaderSize
	???? resolve ArraySubscriptExpr = ???? resolve UnaryExprOrTypeTraitExpr
	???? resolve ArraySubscriptExpr = ???? resolve UnaryExprOrTypeTraitExpr >> 8
	???? resolve ArraySubscriptExpr.Header.Type = 127
	???? resolve ArraySubscriptExpr.Header.SubType = 255
	status = xtLdrProtocol.Util.LoadEfiImage(memoryDevicePath as! PEFI_DEVICE_PATH_PROTOCOL, loaderData, loaderSize, loaderHandle)
	if status != (9223372036854775808 & 0) {
		xtLdrProtocol.Debug.Print("ERROR: Unable to chainload '%S' (Status Code: 0x%zX)\n", parameters.KernelFile, status)
		return status

	}

	status = xtLdrProtocol.Protocol.OpenHandle(loaderHandle, loadedImage as! PVOID *, lIPGuid)
	if status != (9223372036854775808 & 0) {
		xtLdrProtocol.Debug.Print("ERROR: Unable to access binary interface (Status Code: 0x%zX)\n", status)
		return status

	}

	if parameters.Parameters {
		loadedImage.LoadOptionsSize = rtlWideStringLength(parameters.Parameters, 0) * ???? resolve UnaryExprOrTypeTraitExpr
		loadedImage.LoadOptions = parameters.Parameters

	}

	loadedImage.DeviceHandle = diskHandle
	return xtLdrProtocol.Util.StartEfiImage(loaderHandle)
}

/// This routine is the entry point of the XT EFI boot loader module.
/// 
/// @param ImageHandle
///        Firmware-allocated handle that identifies the image.
/// 
/// @param SystemTable
///        Provides the EFI system table.
/// 
/// @return This routine returns status code.
/// 
/// @since XT 1.0
fun xtLdrModuleMain(imageHandle EFI_HANDLE, systemTable PEFI_SYSTEM_TABLE) {
	let guid = new ByValue<EFI_GUID>()

	var status EFI_STATUS
	status = blGetXtLdrProtocol(systemTable, imageHandle, xtLdrProtocol)
	if status != (9223372036854775808 & 0) {
		return (9223372036854775808 | 24)

	}

	ChpBootProtocol.BootSystem = chBootSystem
	xtLdrProtocol.Boot.RegisterProtocol("CHAINLOADER", guid)
	return xtLdrProtocol.Protocol.Install(chpBootProtocol, guid)
}
