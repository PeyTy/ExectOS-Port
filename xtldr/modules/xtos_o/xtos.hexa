// Hexa 2024 from clang 15.0.3var __UNIQUE_ID_author0

var __UNIQUE_ID_description1

var __UNIQUE_ID_softdeps2

var __UNIQUE_ID_license3

var __UNIQUE_ID_version4

var xtLdrProtocol

var xtPeCoffProtocol

var xtBootProtocol


/// Returns information about frame buffer in XTOS compatible format.
/// 
/// @param InformationBlock
///        A pointer to memory area containing XT structure where all the information will be stored.
/// 
/// @return This routine does not return any value.
/// 
/// @since XT 1.0
fun xtGetDisplayInformation(frameBufferResource PSYSTEM_RESOURCE_FRAMEBUFFER, frameBufferBase PEFI_PHYSICAL_ADDRESS, frameBufferSize PULONG_PTR, frameBufferModeInfo PXTBL_FRAMEBUFFER_MODE_INFORMATION) {
	frameBufferResource.Header.PhysicalAddress = *frameBufferBase as! PVOID
	frameBufferResource.Header.ResourceType = systemResourceFrameBuffer
	frameBufferResource.Header.ResourceSize = ???? resolve UnaryExprOrTypeTraitExpr
	frameBufferResource.BufferSize = *frameBufferSize
	frameBufferResource.Width = frameBufferModeInfo.Width
	frameBufferResource.Height = frameBufferModeInfo.Height
	frameBufferResource.Depth = frameBufferModeInfo.Depth
	frameBufferResource.BitsPerPixel = frameBufferModeInfo.BitsPerPixel
	frameBufferResource.PixelsPerScanLine = frameBufferModeInfo.PixelsPerScanLine
	frameBufferResource.Pitch = frameBufferModeInfo.Pitch
	frameBufferResource.Pixels.BlueShift = frameBufferModeInfo.PixelInformation.BlueShift
	frameBufferResource.Pixels.BlueSize = frameBufferModeInfo.PixelInformation.BlueSize
	frameBufferResource.Pixels.GreenShift = frameBufferModeInfo.PixelInformation.GreenShift
	frameBufferResource.Pixels.GreenSize = frameBufferModeInfo.PixelInformation.GreenSize
	frameBufferResource.Pixels.RedShift = frameBufferModeInfo.PixelInformation.RedShift
	frameBufferResource.Pixels.RedSize = frameBufferModeInfo.PixelInformation.RedSize
	frameBufferResource.Pixels.ReservedShift = frameBufferModeInfo.PixelInformation.ReservedShift
	frameBufferResource.Pixels.ReservedSize = frameBufferModeInfo.PixelInformation.ReservedSize
}

fun xtGetMemoryDescriptorList(pageMap PXTBL_PAGE_MAPPING, virtualAddress PVOID *, memoryDescriptorList PLIST_ENTRY) {
	var address EFI_PHYSICAL_ADDRESS
	var status EFI_STATUS
	var pages ULONGLONG
	pages = ((((pageMap.MapSize + 1) * ???? resolve UnaryExprOrTypeTraitExpr) >> 12) + (???? resolve ConditionalOperator)) as! ULONGLONG
	status = xtLdrProtocol.Memory.AllocatePages(pages, address)
	if status != (9223372036854775808 & 0) {
		return status

	}

	status = xtLdrProtocol.Memory.MapVirtualMemory(pageMap, *virtualAddress, address as! PVOID, pages, loaderMemoryData)
	if status != (9223372036854775808 & 0) {
		xtLdrProtocol.Memory.FreePages(address, pages)
		return status

	}

	var physicalBase PVOID = address as! PVOID
	let listEntry = new ByValue<PLIST_ENTRY>()

	listEntry = pageMap.MemoryMap.Flink
	while listEntry != pageMap.MemoryMap {
		let memoryMapping = new ByValue<PXTBL_MEMORY_MAPPING>()

		let memoryDescriptor = new ByValue<PLOADER_MEMORY_DESCRIPTOR>()

		memoryDescriptor.MemoryType = memoryMapping.MemoryType
		memoryDescriptor.BasePage = memoryMapping.PhysicalAddress as! UINT_PTR / 4096
		memoryDescriptor.PageCount = memoryMapping.NumberOfPages
		rtlInsertTailList(memoryDescriptorList, memoryDescriptor.ListEntry)
		address = address + ???? resolve UnaryExprOrTypeTraitExpr
		listEntry = listEntry.Flink

	}

	xtLdrProtocol.Memory.PhysicalListToVirtual(pageMap, memoryDescriptorList, physicalBase, *virtualAddress)
	return (9223372036854775808 & 0)
}

fun xtGetSystemResourcesList(pageMap PXTBL_PAGE_MAPPING, virtualAddress PVOID *, systemResourcesList PLIST_ENTRY) {
	var status XTSTATUS
	var protocolHandle EFI_HANDLE
	let acpiGuid = new ByValue<EFI_GUID>()

	let frameBufGuid = new ByValue<EFI_GUID>()

	let acpiProtocol = new ByValue<PXTBL_ACPI_PROTOCOL>()

	let frameBufProtocol = new ByValue<PXTBL_FRAMEBUFFER_PROTOCOL>()

	let fbModeInfo = new ByValue<XTBL_FRAMEBUFFER_MODE_INFORMATION>()

	var fbAddress EFI_PHYSICAL_ADDRESS
	var fbSize ULONG_PTR
	var frameBufferPages UINT
	let frameBufferResource = new ByValue<PSYSTEM_RESOURCE_FRAMEBUFFER>()

	let acpiResource = new ByValue<PSYSTEM_RESOURCE_ACPI>()

	var pages ULONGLONG
	var address EFI_PHYSICAL_ADDRESS
	var physicalBase PVOID
	var virtualBase PVOID
	pages = (((???? resolve UnaryExprOrTypeTraitExpr + ???? resolve UnaryExprOrTypeTraitExpr) >> 12) + (???? resolve ConditionalOperator)) as! ULONGLONG
	status = xtLdrProtocol.Memory.AllocatePages(pages, address)
	if status != (9223372036854775808 & 0) {
		return status

	}

	status = xtLdrProtocol.Memory.MapVirtualMemory(pageMap, *virtualAddress, address as! PVOID, pages, loaderFirmwarePermanent)
	if status != (9223372036854775808 & 0) {
		xtLdrProtocol.Memory.FreePages(address, pages)
		return status

	}

	physicalBase = address as! PVOID
	virtualBase = *virtualAddress
	??? CompoundStmt CompoundAssignOperator
	acpiResource = address as! PSYSTEM_RESOURCE_ACPI
	rtlZeroMemory(acpiResource, ???? resolve UnaryExprOrTypeTraitExpr)
	status = xtLdrProtocol.Protocol.Open(protocolHandle, acpiProtocol as! PVOID *, acpiGuid)
	if status != (9223372036854775808 & 0) {
		return status

	}

	acpiResource.Header.ResourceType = systemResourceAcpi
	acpiResource.Header.ResourceSize = ???? resolve UnaryExprOrTypeTraitExpr
	acpiProtocol.GetApicBase(acpiResource.ApicBase)
	acpiProtocol.GetAcpiDescriptionPointer(acpiResource.Header.PhysicalAddress)
	acpiResource.Header.VirtualAddress = 0
	rtlInsertTailList(systemResourcesList, acpiResource.Header.ListEntry)
	xtLdrProtocol.Protocol.Close(protocolHandle, frameBufGuid)
	address = address + ???? resolve UnaryExprOrTypeTraitExpr
	frameBufferResource = address as! PSYSTEM_RESOURCE_FRAMEBUFFER
	rtlZeroMemory(frameBufferResource, ???? resolve UnaryExprOrTypeTraitExpr)
	status = xtLdrProtocol.Protocol.Open(protocolHandle, frameBufProtocol as! PVOID *, frameBufGuid)
	if status == (9223372036854775808 & 0) {
		status = frameBufProtocol.GetDisplayInformation(fbAddress, fbSize, fbModeInfo)
		if status == (9223372036854775808 & 0) {
			xtGetDisplayInformation(frameBufferResource, fbAddress, fbSize, fbModeInfo)

		}


	}

	if status != (9223372036854775808 & 0) {
		return status

	}

	frameBufferPages = (((fbSize) >> 12) + (???? resolve ConditionalOperator))
	frameBufferResource.Header.VirtualAddress = *virtualAddress
	xtLdrProtocol.Memory.MapVirtualMemory(pageMap, frameBufferResource.Header.VirtualAddress, frameBufferResource.Header.PhysicalAddress, frameBufferPages, loaderFirmwarePermanent)
	xtLdrProtocol.Protocol.Close(protocolHandle, frameBufGuid)
	??? CompoundStmt CompoundAssignOperator
	rtlInsertTailList(systemResourcesList, frameBufferResource.Header.ListEntry)
	xtLdrProtocol.Memory.PhysicalListToVirtual(pageMap, systemResourcesList, physicalBase, virtualBase)
	return (9223372036854775808 & 0)
}

/// Starts the operating system according to the provided parameters using XTOS boot protocol.
/// 
/// @param Parameters
///        Input parameters with detailed system configuration like boot device or kernel path.
/// 
/// @return This routine returns a status code.
/// 
/// @since XT 1.0
fun xtBootSystem(parameters PXTBL_BOOT_PARAMETERS) {
	let peCoffProtocolGuid = new ByValue<EFI_GUID>()

	var diskHandle EFI_HANDLE
	var protocolHandle EFI_HANDLE
	let fsHandle = new ByValue<PEFI_FILE_HANDLE>()

	let bootDir = new ByValue<PEFI_FILE_HANDLE>()

	var systemPath PWCHAR
	var status EFI_STATUS
	xtLdrProtocol.Debug.Print("XTOS boot protocol activated\n")
	status = xtLdrProtocol.Protocol.Open(protocolHandle, xtPeCoffProtocol as! PVOID *, peCoffProtocolGuid)
	if status != (9223372036854775808 & 0) {
		xtLdrProtocol.Debug.Print("ERROR: Unable to load PE/COFF image protocol\n")
		return (9223372036854775808 | 24)

	}

	if parameters.DevicePath == (0 as! PVOID) {
		xtLdrProtocol.Debug.Print("ERROR: No device path provided, unable to boot system\n")
		return (9223372036854775808 | 2)

	}

	if parameters.SystemPath != (0 as! PVOID) {
		if ???? resolve ArraySubscriptExpr == ???? resolve CharacterLiteral {
			???? resolve ArraySubscriptExpr = ???? resolve CharacterLiteral

		}

		systemPath = ???? resolve ArraySubscriptExpr
		while *systemPath {
			if ((*systemPath | 32) - ???? resolve CharacterLiteral >= 26) and ((*systemPath - ???? resolve CharacterLiteral) >= 10) {
				xtLdrProtocol.Debug.Print("ERROR: System path does not point to the valid XTOS installation\n")
				return (9223372036854775808 | 2)

			}

			??? CompoundStmt UnaryOperator

		}


	} else {
		xtLdrProtocol.Debug.Print("WARNING: No system path set, falling back to defaults\n")
		parameters.SystemPath = "\\ExectOS"

	}

	if parameters.KernelFile == (0 as! PVOID) {
		xtLdrProtocol.Debug.Print("WARNING: No kernel file specified, falling back to defaults\n")
		parameters.KernelFile = "xtoskrnl.exe"

	}

	if parameters.Parameters == (0 as! PVOID) {
		parameters.Parameters = ""

	}

	xtLdrProtocol.Debug.Print("[XTOS] ARC Path: %S\n[XTOS] System Path: %S\n[XTOS] Kernel File: %S\n[XTOS] Boot Arguments: %S\n", parameters.ArcName, parameters.SystemPath, parameters.KernelFile, parameters.Parameters)
	status = xtLdrProtocol.Disk.OpenVolume((0 as! PVOID), diskHandle, fsHandle)
	if status != (9223372036854775808 & 0) {
		xtLdrProtocol.Debug.Print("ERROR: Unable to open boot volume\n")
		return status

	}

	rtlConcatenateWideString(parameters.SystemPath, "\\Boot", 0)
	status = fsHandle.Open(fsHandle, bootDir, parameters.SystemPath, 1, 0)
	fsHandle.Close(fsHandle)
	if status == (9223372036854775808 | 14) {
		xtLdrProtocol.Debug.Print("ERROR: System boot directory not found\n")
		xtLdrProtocol.Disk.CloseVolume(diskHandle)
		return status

	} else {
		??? CompoundStmt CompoundStmt

	}

	return xtpBootSequence(bootDir, parameters)
}

/// This routine initiates an XTOS boot sequence.
/// 
/// @param BootDir
///        An EFI handle to the XTOS boot directory.
/// 
/// @param Parameters
///        Input parameters with detailed system configuration like boot device or kernel path.
/// 
/// @return This routine returns a status code.
/// 
/// @since XT 1.0
fun xtpBootSequence(bootDir PEFI_FILE_HANDLE, parameters PXTBL_BOOT_PARAMETERS) {
	let loadedImageGuid = new ByValue<EFI_GUID>()

	let frameBufGuid = new ByValue<EFI_GUID>()

	let kernelParameters = new ByValue<PKERNEL_INITIALIZATION_BLOCK>()

	let frameBufProtocol = new ByValue<PXTBL_FRAMEBUFFER_PROTOCOL>()

	let imageContext = new ByValue<PPECOFF_IMAGE_CONTEXT>()

	let imageProtocol = new ByValue<PEFI_LOADED_IMAGE_PROTOCOL>()

	var virtualAddress PVOID
	var virtualMemoryArea PVOID
	var kernelEntryPoint PXT_ENTRY_POINT
	var protocolHandle EFI_HANDLE
	var status EFI_STATUS
	let pageMap = new ByValue<XTBL_PAGE_MAPPING>()

	xtLdrProtocol.Debug.Print("Initializing XTOS startup sequence\n")
	status = xtLdrProtocol.Protocol.Open(protocolHandle, frameBufProtocol as! PVOID *, frameBufGuid)
	if status == (9223372036854775808 & 0) {
		frameBufProtocol.Initialize()
		frameBufProtocol.SetScreenResolution(0, 0)

	}

	xtLdrProtocol.Protocol.Close(protocolHandle, frameBufGuid)
	virtualMemoryArea = 18446735277616529408 as! PVOID
	virtualAddress = (18446735277616529408 + 34359738368) as! PVOID
	xtLdrProtocol.Memory.InitializePageMap(pageMap, 3, size4K)
	status = xtLdrProtocol.Memory.MapEfiMemory(pageMap, virtualMemoryArea, (0 as! PVOID))
	if status != (9223372036854775808 & 0) {
		return status

	}

	status = xtpLoadModule(bootDir, parameters.KernelFile, virtualAddress, loaderSystemCode, imageContext)
	if status != (9223372036854775808 & 0) {
		return status

	}

	status = xtLdrProtocol.Memory.MapVirtualMemory(pageMap, imageContext.VirtualAddress, imageContext.PhysicalAddress, imageContext.ImagePages, 0)
	if status != (9223372036854775808 & 0) {
		return status

	}

	??? CompoundStmt CompoundAssignOperator
	status = xtpInitializeApicBase(pageMap)
	if status != (9223372036854775808 & 0) {
		xtLdrProtocol.Debug.Print("Failed to initialize APIC (Status Code: 0x%zX)\n", status)
		return status

	}

	kernelParameters = virtualAddress as! PKERNEL_INITIALIZATION_BLOCK
	status = xtpInitializeLoaderBlock(pageMap, virtualAddress, parameters)
	if status != (9223372036854775808 & 0) {
		xtLdrProtocol.Debug.Print("Failed to setup kernel initialization block (Status Code: 0x%zX)\n", status)
		return status

	}

	xtPeCoffProtocol.GetEntryPoint(imageContext, kernelEntryPoint as! PVOID)
	bootDir.Close(bootDir)
	xtLdrProtocol.Protocol.Open(protocolHandle, imageProtocol as! PVOID *, loadedImageGuid)
	status = xtEnablePaging(pageMap)
	if status != (9223372036854775808 & 0) {
		xtLdrProtocol.Debug.Print("Failed to enable paging (Status Code: 0x%zX)\n", status)
		return status

	}

	xtLdrProtocol.Debug.Print("Booting the XTOS kernel\n")
	kernelEntryPoint(kernelParameters)
	return (9223372036854775808 & 0)
}

/// Checks if APIC is present in the system and finds its base address.
/// 
/// @param MemoryMappings
///        Supplies a pointer to linked list containing all memory mappings.
/// 
/// @return This routine returns an EFI status code.
/// 
/// @since XT 1.0
fun xtpInitializeApicBase(pageMap PXTBL_PAGE_MAPPING) {
	let acpiGuid = new ByValue<EFI_GUID>()

	let acpiProtocol = new ByValue<PXTBL_ACPI_PROTOCOL>()

	var protocolHandle EFI_HANDLE
	var apicBaseAddress PVOID
	var status EFI_STATUS
	status = xtLdrProtocol.Protocol.Open(protocolHandle, acpiProtocol as! PVOID *, acpiGuid)
	if status != (9223372036854775808 & 0) {
		return status

	}

	status = acpiProtocol.GetApicBase(apicBaseAddress)
	if status != (9223372036854775808 & 0) {
		return status

	}

	xtLdrProtocol.Memory.MapVirtualMemory(pageMap, 18446744073709420544 as! PVOID, apicBaseAddress, 1, loaderFirmwarePermanent)
	return (9223372036854775808 & 0)
}

/// Initializes and maps the kernel initialization block.
/// 
/// @param MemoryMappings
///        Supplies a pointer to linked list containing all memory mappings.
/// 
/// @param VirtualAddress
///        Supplies a pointer to the next valid, free and available virtual address.
/// 
/// @return This routine returns a status code.
/// 
/// @since XT 1.0
fun xtpInitializeLoaderBlock(pageMap PXTBL_PAGE_MAPPING, virtualAddress PVOID *, parameters PXTBL_BOOT_PARAMETERS) {
	let loaderBlock = new ByValue<PKERNEL_INITIALIZATION_BLOCK>()

	var address EFI_PHYSICAL_ADDRESS
	var status EFI_STATUS
	var blockPages UINT
	blockPages = (((???? resolve UnaryExprOrTypeTraitExpr) >> 12) + (???? resolve ConditionalOperator))
	status = xtLdrProtocol.Memory.AllocatePages(blockPages, address)
	if status != (9223372036854775808 & 0) {
		return status

	}

	loaderBlock = address as! UINT_PTR as! PKERNEL_INITIALIZATION_BLOCK
	rtlZeroMemory(loaderBlock, ???? resolve UnaryExprOrTypeTraitExpr)
	loaderBlock.BlockSize = ???? resolve UnaryExprOrTypeTraitExpr
	loaderBlock.BlockVersion = 1
	loaderBlock.ProtocolVersion = 1
	loaderBlock.LoaderInformation.DbgPrint = xtLdrProtocol.Debug.Print
	loaderBlock.LoaderInformation.PageMapLevel = 3
	loaderBlock.FirmwareInformation.FirmwareType = systemFirmwareEfi
	loaderBlock.FirmwareInformation..EfiFirmware.EfiVersion = 0
	loaderBlock.FirmwareInformation..EfiFirmware.EfiRuntimeServices = (0 as! PVOID)
	rtlCopyMemory(loaderBlock.KernelParameters, parameters.Parameters, (rtlWideStringLength(parameters.Parameters, 0) + 1) * ???? resolve UnaryExprOrTypeTraitExpr)
	xtLdrProtocol.Memory.MapVirtualMemory(pageMap, *virtualAddress, loaderBlock as! PVOID, blockPages, loaderSystemBlock)
	??? CompoundStmt CompoundAssignOperator
	rtlInitializeListHead(loaderBlock.SystemResourcesListHead)
	xtGetSystemResourcesList(pageMap, virtualAddress, loaderBlock.SystemResourcesListHead)
	rtlInitializeListHead(loaderBlock.MemoryDescriptorListHead)
	xtGetMemoryDescriptorList(pageMap, virtualAddress, loaderBlock.MemoryDescriptorListHead)
	return (9223372036854775808 & 0)
}

/// Loads XTOS PE/COFF module.
/// 
/// @param SystemDir
///        An EFI handle to the opened system directory containing a module that will be loaded.
/// 
/// @param FileName
///        An on disk filename of the module that will be loaded.
/// 
/// @param VirtualAddress
///        Optional virtual address pointing to the memory area where PE/COFF file will be loaded.
/// 
/// @param MemoryType
///        Supplies the type of memory to be assigned to the memory descriptor.
/// 
/// @param ImageContext
///        Supplies pointer to the memory area where loaded PE/COFF image context will be stored.
/// 
/// @return This routine returns a status code.
/// 
/// @since XT 1.0
fun xtpLoadModule(systemDir PEFI_FILE_HANDLE, fileName PWCHAR, virtualAddress PVOID, memoryType LOADER_MEMORY_TYPE, imageContext PPECOFF_IMAGE_CONTEXT *) {
	let moduleHandle = new ByValue<PEFI_FILE_HANDLE>()

	var machineType USHORT
	var subSystem USHORT
	var status EFI_STATUS
	xtLdrProtocol.Debug.Print("Loading %S ... \n", fileName)
	status = systemDir.Open(systemDir, moduleHandle, fileName, 1, 0)
	if status != (9223372036854775808 & 0) {
		xtLdrProtocol.Debug.Print("ERROR: Failed to open '%S'\n", fileName)
		return status

	}

	status = xtPeCoffProtocol.LoadImage(moduleHandle, memoryType, virtualAddress, imageContext as! PVOID)
	if status != (9223372036854775808 & 0) {
		xtLdrProtocol.Debug.Print("ERROR: Failed to load '%S'\n", fileName)
		return status

	}

	moduleHandle.Close(moduleHandle)
	xtPeCoffProtocol.GetMachineType(*imageContext, machineType)
	if machineType != 34404 {
		xtLdrProtocol.Debug.Print("ERROR: Loaded incompatible PE/COFF image (machine type mismatch)\n")
		return (9223372036854775808 | 25)

	}

	xtPeCoffProtocol.GetSubSystem(*imageContext, subSystem)
	if subSystem != 20 and subSystem != 21 and subSystem != 22 {
		xtLdrProtocol.Debug.Print("WARNING: Loaded PE/COFF image with non-XT subsystem set\n")

	}

	xtLdrProtocol.Debug.Print("Loaded %S at PA: %P, VA: %P\n", fileName, (*imageContext).PhysicalAddress, (*imageContext).VirtualAddress)
	return (9223372036854775808 & 0)
}

/// This routine is the entry point of the XT EFI boot loader module.
/// 
/// @param ImageHandle
///        Firmware-allocated handle that identifies the image.
/// 
/// @param SystemTable
///        Provides the EFI system table.
/// 
/// @return This routine returns status code.
/// 
/// @since XT 1.0
fun xtLdrModuleMain(imageHandle EFI_HANDLE, systemTable PEFI_SYSTEM_TABLE) {
	let guid = new ByValue<EFI_GUID>()

	var status EFI_STATUS
	status = blGetXtLdrProtocol(systemTable, imageHandle, xtLdrProtocol)
	if status != (9223372036854775808 & 0) {
		return (9223372036854775808 | 24)

	}

	XtBootProtocol.BootSystem = xtBootSystem
	xtLdrProtocol.Boot.RegisterProtocol("XTOS", guid)
	return xtLdrProtocol.Protocol.Install(xtBootProtocol, guid)
}
