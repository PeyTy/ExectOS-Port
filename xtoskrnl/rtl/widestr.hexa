// Hexa 2024 from clang 15.0.3
/// Compares at most specified number of characters of two C wide strings.
/// 
/// @param String1
///        Wide string to be compared.
/// 
/// @param String2
///        Wide string to be compared.
/// 
/// @param Length
///        Maximum number of characters to compare. If no limit set, it compares whole wide strings.
/// 
/// @return Integral value indicating the relationship between the wide strings.
/// 
/// @since XT 1.0
fun rtlCompareWideString(string1 Const PWCHAR, string2 Const PWCHAR, length SIZE_T) {
	var index SIZE_T
	??? CompoundStmt ForStmt
	return 0
}

/// Compares at most specified number of characters of two C wide strings, while ignoring differences in case.
/// 
/// @param String1
///        Wide string to be compared.
/// 
/// @param String2
///        Wide string to be compared.
/// 
/// @param Length
///        Maximum number of characters to compare. If no limit set, it compares whole wide strings.
/// 
/// @return Integral value indicating the relationship between the wide strings.
/// 
/// @since XT 1.0
fun rtlCompareWideStringInsensitive(string1 Const PWCHAR, string2 Const PWCHAR, length SIZE_T) {
	var character1 WCHAR
	var character2 WCHAR
	var index ULONG = 0
	while ???? resolve ArraySubscriptExpr != ???? resolve CharacterLiteral and ???? resolve ArraySubscriptExpr != ???? resolve CharacterLiteral {
		if index != 0 and index == length {
			??? CompoundStmt BreakStmt

		}

		character1 = ???? resolve ArraySubscriptExpr
		character2 = ???? resolve ArraySubscriptExpr
		if ???? resolve ArraySubscriptExpr >= ???? resolve CharacterLiteral and ???? resolve ArraySubscriptExpr <= ???? resolve CharacterLiteral {
			character1 = ???? resolve ArraySubscriptExpr - ???? resolve CharacterLiteral + ???? resolve CharacterLiteral

		}

		if ???? resolve ArraySubscriptExpr >= ???? resolve CharacterLiteral and ???? resolve ArraySubscriptExpr <= ???? resolve CharacterLiteral {
			character2 = ???? resolve ArraySubscriptExpr - ???? resolve CharacterLiteral + ???? resolve CharacterLiteral

		}

		if character1 != character2 {
			return ???? resolve ConditionalOperator

		}

		??? CompoundStmt UnaryOperator

	}

	return 0
}

/// Appends a copy of the source wide string to the end of the destination wide string.
/// 
/// @param Destination
///        Supplies a pointer to the null-terminated wide string to append to.
/// 
/// @param Source
///        Supplies a pointer to the null-terminated wide string to copy from.
/// 
/// @param Count
///        Sets a maximum number of wide characters to copy. If no limit set, appends whole wide string.
/// 
/// @return This routine returns a copy of a destination wide string.
/// 
/// @since XT 1.0
fun rtlConcatenateWideString(destination PWCHAR, source PWCHAR, count SIZE_T) {
	var destString PWCHAR = destination
	while *destination {
		??? CompoundStmt UnaryOperator

	}

	if count > 0 {
		??? CompoundStmt DoStmt
		*destination = ???? resolve CharacterLiteral

	} else {
		while (*++destination = *++source) != 0 {

		}


	}

	return destString
}

/// Copies a wide string from a buffer into another buffer, ensuring that the destination string is NULL-terminated.
/// 
/// @param Destination
///        Supplies a pointer to the destination buffer.
/// 
/// @param Source
///        Supplies a pointer to the source buffer.
/// 
/// @param Length
///        Supplies the length of the wide string to copy.
/// 
/// @return This routine does not return any value.
/// 
/// @since XT 1.0
fun rtlCopyWideString(destination PWCHAR, source Const PWCHAR, length ULONG) {
	var index ULONG
	??? CompoundStmt ForStmt
	???? resolve ArraySubscriptExpr = ???? resolve CharacterLiteral
}

/// Formats a wide string according to the given printf-alike format string.
/// 
/// @param Context
///        Supplies a pointer to the print context structure.
/// 
/// @param Format
///        Supplies a pointer to the printf-alike format string.
/// 
/// @param ArgumentList
///        Supplies a list of arguments to the format string.
/// 
/// @return This routine returns a status code.
/// 
/// @since XT 1.0
fun rtlFormatWideString(context PRTL_PRINT_CONTEXT, format PCWSTR, argumentList VA_LIST) {
	var localArgumentList VA_LIST
	var status XTSTATUS
	var index ULONG
	if context == (0 as! PVOID) or context.WriteWideCharacter == (0 as! PVOID) {
		return fALSE

	}

	if format == (0 as! PVOID) {
		format = "(null)"

	}

	__builtin_va_copy(localArgumentList, argumentList)
	index = 0
	while ???? resolve ArraySubscriptExpr != ???? resolve CharacterLiteral {
		if ???? resolve ArraySubscriptExpr == ???? resolve CharacterLiteral {
			status = rtlpFormatWideStringArgumentSpecifier(context, format, localArgumentList, index)

		} else {
			status = rtlpWriteWideCharacter(context, ???? resolve ArraySubscriptExpr)
			??? CompoundStmt UnaryOperator

		}

		if status != (0 as! XTSTATUS) {
			return status

		}


	}

	__builtin_va_end(localArgumentList)
	return (0 as! XTSTATUS)
}

/// Reverses a characters order in a wide string. It modifies the original, input variable.
/// 
/// @param String
///        Supplies a pointer to the wide string to reverse.
/// 
/// @param Length
///        Supplies the length of the wide string to reverse.
/// 
/// @return This routine does not return any value.
/// 
/// @since XT 1.0
fun rtlReverseWideString(string PWCHAR, length ULONG) {
	var tempChar WCHAR
	var index ULONG
	??? CompoundStmt ForStmt
}

/// Finds the next token in a null-terminated wide string.
/// 
/// @param String
///        Pointer to the null-terminated wide string to tokenize.
/// 
/// @param Delimiter
///        Pointer to the null-terminated wide string identifying delimiters.
/// 
/// @param SavePtr
///        Pointer to an object used to store routine internal state.
/// 
/// @return Pointer to the beginning of the next token or NULL if there are no more tokens.
/// 
/// @since: XT 1.0
fun rtlTokenizeWideString(string PWCHAR, delimiter Const PWCHAR, savePtr PWCHAR *) {
	var span PWCHAR
	var token PWCHAR
	var char WCHAR
	var spanChar WCHAR
	if string == (0 as! PVOID) and (string = *savePtr) == (0 as! PVOID) {
		return (0 as! PVOID)

	}

	char = *++string
	if char == ???? resolve CharacterLiteral {
		*savePtr = (0 as! PVOID)
		return (0 as! PVOID)

	}

	token = string - 1
	??? CompoundStmt ForStmt
}

/// Removes certain characters from a beginning of the wide string.
/// 
/// @param String
///        Pointer to the null-terminated wide string to be trimmed.
/// 
/// @return This routine returns a pointer to the left-trimmed wide string.
/// 
/// @since XT 1.0
fun rtlTrimLeftWideString(string Const PWCHAR) {
	var start PWCHAR
	start = string
	while *start == ???? resolve CharacterLiteral or *start == ???? resolve CharacterLiteral or *start == ???? resolve CharacterLiteral or *start == ???? resolve CharacterLiteral or *start == ???? resolve CharacterLiteral or *start == ???? resolve CharacterLiteral {
		??? CompoundStmt UnaryOperator

	}

	return start
}

/// Removes certain characters from the end of the wide string.
/// 
/// @param String
///        Pointer to the null-terminated wide string to be trimmed.
/// 
/// @return This routine returns a pointer to the right-trimmed wide string.
/// 
/// @since XT 1.0
fun rtlTrimRightWideString(string Const PWCHAR) {
	var end PWCHAR
	end = string + rtlWideStringLength(string, 0)
	while (end != string) and (*end == ???? resolve CharacterLiteral or *end == ???? resolve CharacterLiteral or *end == ???? resolve CharacterLiteral or *end == ???? resolve CharacterLiteral or *end == ???? resolve CharacterLiteral or *end == ???? resolve CharacterLiteral) {
		??? CompoundStmt UnaryOperator

	}

	*end = 0
	return string
}

/// Removes certain characters from the beginning and the end of the wide string.
/// 
/// @param String
///        Pointer to the null-terminated wide string to be trimmed.
/// 
/// @return This routine returns a pointer to the trimmed wide string.
/// 
/// @since XT 1.0
fun rtlTrimWideString(string Const PWCHAR) {
	return rtlTrimLeftWideString(rtlTrimRightWideString(string))
}

/// Calculates the length of a given wide string.
/// 
/// @param String
///        Pointer to the null-terminated wide string to be examined.
/// 
/// @param MaxLength
///        Maximum number of wide characters to examine. If no limit set, it examines whole string.
/// 
/// @return The length of the null-terminated wide string.
/// 
/// @since: XT 1.0
fun rtlWideStringLength(string Const PWCHAR, maxLength SIZE_T) {
	var length SIZE_T
	if string == (0 as! PVOID) {
		return 0

	}

	??? CompoundStmt ForStmt
	return length
}

/// Formats a wide string according to the given printf-alike format string and a list of arguments.
/// 
/// @param Context
///        Supplies a pointer to the print context structure.
/// 
/// @param Format
///        Supplies a pointer to the printf-alike format string.
/// 
/// @param ArgumentList
///        Supplies a list of arguments to the format string.
/// 
/// @param Index
///        Supplies a pointer to the position of the current format specifier, that will be advanced beyond the specifier.
/// 
/// @return This routine returns a status code.
/// 
/// @since XT 1.0
fun rtlpFormatWideStringArgumentSpecifier(context PRTL_PRINT_CONTEXT, format PCWSTR, argumentList PVA_LIST, index PULONG) {
	let formatProperties = new ByValue<RTL_PRINT_FORMAT_PROPERTIES>()

	let unicodeStrArg = new ByValue<PUNICODE_STRING>()

	var specifier WCHAR
	var wideCharArg WCHAR
	let ansiStrArg = new ByValue<PANSI_STRING>()

	var specifierValue LONGLONG
	var argumentsCopy VA_LIST
	var floatArg LARGE_DOUBLE
	var formatIndex PCWSTR
	var argPosition ULONG
	var wideStrArg PWCHAR
	var intArg ULONGLONG
	var status XTSTATUS
	let guidArg = new ByValue<PGUID>()

	var strArg PCHAR
	var charArg CHAR
	formatIndex = format + *index + 1
	argPosition = 0
	rtlZeroMemory(formatProperties, ???? resolve UnaryExprOrTypeTraitExpr)
	FormatProperties.IntegerSize = ???? resolve UnaryExprOrTypeTraitExpr
	FormatProperties.Precision = -1
	__builtin_va_copy(argumentsCopy, *argumentList)
	if (*formatIndex >= ???? resolve CharacterLiteral) and (*formatIndex <= ???? resolve CharacterLiteral) {
		specifierValue = rtlpGetWideStringSpecifierValue(formatIndex as! PWSTR *)
		if *formatIndex == ???? resolve CharacterLiteral {
			argPosition = specifierValue as! ULONG
			??? CompoundStmt UnaryOperator

		} else {
			FormatProperties.FieldWidth = specifierValue as! ULONG

		}


	}

	while tRUE {
		if *formatIndex == ???? resolve CharacterLiteral {
			??? CompoundStmt CompoundAssignOperator

		} else {
			??? CompoundStmt CompoundStmt
			if *formatIndex == ???? resolve CharacterLiteral {
				??? CompoundStmt CompoundAssignOperator

			} else {
				??? CompoundStmt CompoundStmt
				if *formatIndex == ???? resolve CharacterLiteral {
					??? CompoundStmt CompoundAssignOperator

				} else {
					??? CompoundStmt CompoundStmt
					??? CompoundStmt CompoundStmt

				}


			}


		}

		??? CompoundStmt UnaryOperator

	}

	if FormatProperties.Flags & 4 {
		??? CompoundStmt CompoundAssignOperator

	}

	if FormatProperties.Flags & 1 {
		??? CompoundStmt CompoundAssignOperator

	}

	if *formatIndex == ???? resolve CharacterLiteral {
		??? CompoundStmt UnaryOperator
		FormatProperties.FieldWidth = (???? resolve ConditionalOperator)

	} else {
		??? CompoundStmt CompoundStmt

	}

	if FormatProperties.FieldWidth < 0 {
		??? CompoundStmt CompoundAssignOperator
		??? CompoundStmt CompoundAssignOperator

	}

	if *formatIndex == ???? resolve CharacterLiteral {
		??? CompoundStmt UnaryOperator
		if *formatIndex == ???? resolve CharacterLiteral {
			??? CompoundStmt UnaryOperator
			FormatProperties.Precision = (???? resolve ConditionalOperator)

		} else {
			??? CompoundStmt CompoundStmt
			??? CompoundStmt CompoundStmt

		}


	}

	if FormatProperties.Precision < 0 {
		FormatProperties.Precision = -1

	}

	specifier = *formatIndex
	??? CompoundStmt SwitchStmt
	specifier = *++formatIndex
	if FormatProperties.Flags & 64 {
		if specifier == ???? resolve CharacterLiteral {
			specifier = ???? resolve CharacterLiteral

		} else {
			??? CompoundStmt CompoundStmt

		}


	}

	??? CompoundStmt CompoundAssignOperator
	??? CompoundStmt SwitchStmt
	if FormatProperties.VariableType == unknown {
		status = rtlpWriteWideStringValue(context, formatProperties, wideCharArg, 1)

	}

	if FormatProperties.VariableType == boolean {
		if argPosition != 0 {
			intArg = rtlpGetWideStringArgument(argumentsCopy, argPosition, FormatProperties.IntegerSize)

		} else {
			intArg = (???? resolve ConditionalOperator)

		}

		if FormatProperties.Flags & 512 {
			wideStrArg = ???? resolve ConditionalOperator

		} else {
			wideStrArg = ???? resolve ConditionalOperator

		}

		status = rtlpWriteWideStringValue(context, formatProperties, wideStrArg, rtlWideStringLength(wideStrArg, 0))

	} else {
		??? CompoundStmt CompoundStmt
		if FormatProperties.VariableType == char {
			if argPosition != 0 {
				charArg = rtlpGetWideStringArgument(argumentsCopy, argPosition, ???? resolve UnaryExprOrTypeTraitExpr) as! UCHAR

			} else {
				charArg = (???? resolve ConditionalOperator)

			}

			status = rtlpWriteWideStringStringValue(context, formatProperties, charArg, 1)

		} else {
			??? CompoundStmt CompoundStmt
			if FormatProperties.VariableType == float {
				if argPosition != 0 {
					FloatArg.QuadPart = rtlpGetWideStringArgument(argumentsCopy, argPosition, ???? resolve UnaryExprOrTypeTraitExpr)

				} else {
					if FormatProperties.Flags & 32 {
						FloatArg.DoublePart = (???? resolve ConditionalOperator)

					} else {
						FloatArg.DoublePart = (???? resolve ConditionalOperator)

					}


				}

				status = rtlpWriteWideStringDoubleValue(context, formatProperties, FloatArg.DoublePart)

			} else {
				??? CompoundStmt CompoundStmt
				if FormatProperties.VariableType == string {
					if argPosition != 0 {
						intArg = rtlpGetWideStringArgument(argumentsCopy, argPosition, ???? resolve UnaryExprOrTypeTraitExpr)
						strArg = intArg as! UINT_PTR as! PCHAR

					} else {
						strArg = (???? resolve ConditionalOperator)

					}

					status = rtlpWriteWideStringStringValue(context, formatProperties, strArg, rtlStringLength(strArg, 0))

				} else {
					??? CompoundStmt CompoundStmt
					if FormatProperties.VariableType == ansiString {
						if argPosition != 0 {
							intArg = rtlpGetWideStringArgument(argumentsCopy, argPosition, ???? resolve UnaryExprOrTypeTraitExpr)
							ansiStrArg = intArg as! UINT_PTR as! PANSI_STRING

						} else {
							ansiStrArg = (???? resolve ConditionalOperator)

						}

						if ansiStrArg != (0 as! PVOID) {
							status = rtlpWriteWideStringStringValue(context, formatProperties, ansiStrArg.Buffer, ansiStrArg.Length)

						}


					} else {
						??? CompoundStmt CompoundStmt

					}


				}


			}


		}


	}

	__builtin_va_end(argumentsCopy)
	??? CompoundStmt CompoundAssignOperator
	return status
}

/// Gets the positional argument by scanning the argument list.
/// 
/// @param ArgumentList
///        Supplies a pointer to the argument list.
/// 
/// @param ArgumentNumber
///        Supplies the argument number.
/// 
/// @param ArgumentSize
///        Supplies the expected size of the argument.
fun rtlpGetWideStringArgument(argumentList PVA_LIST, argumentNumber ULONG, argumentSize LONG) {
	var argumentsCopy VA_LIST
	var value ULONGLONG
	var index ULONG
	__builtin_va_copy(argumentsCopy, *argumentList)
	??? CompoundStmt ForStmt
	value = 0
	??? CompoundStmt SwitchStmt
	__builtin_va_end(argumentsCopy)
	return value
}

/// Gets the specifier integer value from the wide string advancing the pointer.
/// 
/// @param Format
///        Supplies a pointer to the wide string format, at integer value position.
/// 
/// @return This routine returns a specifier integer value read from wide string format, or zero if no valid value found.
/// 
/// @since XT 1.0
fun rtlpGetWideStringSpecifierValue(format PWCHAR *) {
	var count ULONG
	var fmt PWCHAR
	fmt = *format
	count = 0
	??? CompoundStmt ForStmt
	return 0
}

/// Writes a wide character to the destination provided by the print context.
/// 
/// @param Context
///        Supplies a pointer to the print context structure.
/// 
/// @param Character
///        Supplies the wide character to write.
/// 
/// @return This routine returns a status code.
/// 
/// @since XT 1.0
fun rtlpWriteWideCharacter(context PRTL_PRINT_CONTEXT, character WCHAR) {
	var status XTSTATUS
	status = context.WriteWideCharacter(character)
	??? CompoundStmt UnaryOperator
	return status
}

/// Writes a wide string custom-formatted value to the destination provided by the print context.
/// 
/// @param Context
///        Supplies a pointer to the print context structure.
/// 
/// @param Format
///        Supplies a pointer to the printf-alike format string.
/// 
/// @param ...
///        Depending on the format string, this routine might expect a sequence of additional arguments.
/// 
/// @return This routine returns a status code.
/// 
/// @since XT 1.0
fun rtlpWriteWideStringCustomValue(context PRTL_PRINT_CONTEXT, format PCWSTR) {
	var arguments VA_LIST
	var status XTSTATUS
	__builtin_va_start(arguments, format)
	status = rtlFormatWideString(context, format, arguments)
	__builtin_va_end(arguments)
	return status
}

fun rtlpWriteWideStringDoubleValue(context PRTL_PRINT_CONTEXT, formatProperties PRTL_PRINT_FORMAT_PROPERTIES, value DOUBLE) {
	var currentExponent LONG
	var digitCount LONG
	var exponent LONG
	var precision LONG
	var precisionIndex LONG
	var significantDigits LONG
	var character WCHAR
	var digit WCHAR
	var exponentCharacter WCHAR
	var signCharacter WCHAR
	var fieldCount ULONG
	var fieldIndex ULONG
	var index ULONG
	var numberLength ULONG
	var buffer WCHAR[15]
	var negativeValue BOOLEAN
	var writeExponent BOOLEAN
	var roundingAmount DOUBLE
	var tenPower DOUBLE
	var nonNumberString PWCHAR
	var parts LARGE_DOUBLE
	var status XTSTATUS
	negativeValue = fALSE
	numberLength = 0
	Parts.DoublePart = value
	precision = formatProperties.Precision
	signCharacter = 0
	if precision == -1 {
		precision = 6

	}

	if (formatProperties.Flags & 8192) and (precision == 0) {
		precision = 1

	}

	if rtlInfiniteDouble(value) {
		if rtlNanDouble(value) {
			if formatProperties.Flags & 512 {
				nonNumberString = "#NAN"

			} else {
				nonNumberString = "#nan"

			}


		} else {
			if formatProperties.Flags & 512 {
				nonNumberString = "#INF"

			} else {
				nonNumberString = "#inf"

			}

			if value < 0 {
				negativeValue = tRUE

			}


		}

		index = 0
		if negativeValue != fALSE {
			???? resolve ArraySubscriptExpr = ???? resolve CharacterLiteral
			??? CompoundStmt UnaryOperator

		} else {
			??? CompoundStmt CompoundStmt
			if formatProperties.Flags & 2 {
				???? resolve ArraySubscriptExpr = ???? resolve CharacterLiteral
				??? CompoundStmt UnaryOperator

			}


		}

		rtlCopyWideString(buffer + index, nonNumberString, ???? resolve UnaryExprOrTypeTraitExpr - index)
		return rtlpWriteWideStringValue(context, formatProperties, buffer, rtlWideStringLength(buffer, 0))

	}

	if formatProperties.Radix == 16 {
		return rtlpWriteWideStringHexDoubleValue(context, formatProperties, value)

	}

	if (Parts.u.HighPart & (9223372036854775808 >> 32)) != 0 {
		??? CompoundStmt CompoundAssignOperator
		negativeValue = tRUE

	}

	exponent = rtlGetBaseExponent(value, tenPower)
	roundingAmount = ???? resolve FloatingLiteral
	writeExponent = (formatProperties.Flags & 4096)
	if (writeExponent == fALSE) and !(formatProperties.Flags & 2048) {
		if (exponent < -4) or (exponent >= precision) {
			writeExponent = tRUE

		}


	}

	digitCount = 0
	if value != ???? resolve FloatingLiteral {
		if (writeExponent != fALSE) or (formatProperties.Flags & 8192) {
			??? CompoundStmt CompoundAssignOperator
			if formatProperties.Flags & 8192 {
				??? CompoundStmt CompoundAssignOperator

			}


		}

		??? CompoundStmt ForStmt
		??? CompoundStmt CompoundAssignOperator
		??? CompoundStmt CompoundAssignOperator
		if value as! LONG > 9 {
			??? CompoundStmt CompoundAssignOperator
			??? CompoundStmt CompoundAssignOperator

		}

		while (value != ???? resolve FloatingLiteral) and (digitCount < 15) {
			???? resolve ArraySubscriptExpr = value as! LONG + ???? resolve CharacterLiteral
			??? CompoundStmt CompoundAssignOperator
			value = (value - value as! LONG as! Double) * ???? resolve FloatingLiteral

		}

		if formatProperties.Flags & 8192 {
			if precision > 0 {
				if digitCount > precision {
					digitCount = precision

				}


			}


		}

		while (digitCount > 1) and (???? resolve ArraySubscriptExpr == ???? resolve CharacterLiteral) {
			??? CompoundStmt CompoundAssignOperator

		}


	}

	if negativeValue {
		signCharacter = ???? resolve CharacterLiteral

	} else {
		??? CompoundStmt CompoundStmt
		if formatProperties.Flags & 2 {
			signCharacter = ???? resolve CharacterLiteral

		}


	}

	significantDigits = digitCount
	if formatProperties.Flags & 8192 {
		if significantDigits > precision {
			significantDigits = precision

		} else {
			??? CompoundStmt CompoundStmt

		}


	}

	numberLength = precision
	if formatProperties.Flags & 1024 {
		??? CompoundStmt CompoundAssignOperator

	} else {
		??? CompoundStmt CompoundStmt
		if precision != 0 {
			??? CompoundStmt CompoundAssignOperator

		}


	}

	if writeExponent {
		??? CompoundStmt CompoundAssignOperator
		if !(formatProperties.Flags & 8192) {
			??? CompoundStmt CompoundAssignOperator

		}

		if exponent < 0 {
			if exponent <= -100 {
				??? CompoundStmt CompoundAssignOperator
				if exponent <= -1000 {
					??? CompoundStmt CompoundAssignOperator

				}


			}


		} else {
			if exponent >= 100 {
				??? CompoundStmt CompoundAssignOperator
				if exponent >= 1000 {
					??? CompoundStmt CompoundAssignOperator

				}


			}


		}


	} else {
		if exponent >= 0 {
			if !(formatProperties.Flags & 8192) {
				??? CompoundStmt CompoundAssignOperator

			}


		} else {
			??? CompoundStmt CompoundAssignOperator
			if formatProperties.Flags & 8192 {
				??? CompoundStmt CompoundAssignOperator
				??? CompoundStmt CompoundAssignOperator

			}


		}


	}

	if signCharacter != 0 {
		??? CompoundStmt CompoundAssignOperator

	}

	fieldCount = 0
	if numberLength < formatProperties.FieldWidth {
		fieldCount = formatProperties.FieldWidth - numberLength

	}

	if (formatProperties.Flags & 4) or (formatProperties.Flags & 8) {
		if signCharacter != 0 {
			status = rtlpWriteWideCharacter(context, signCharacter)
			if status != (0 as! XTSTATUS) {
				return status

			}


		}

		signCharacter = 0

	}

	if !(formatProperties.Flags & 4) or (formatProperties.Flags & 8) {
		if formatProperties.Flags & 8 {
			character = ???? resolve CharacterLiteral

		} else {
			character = ???? resolve CharacterLiteral

		}

		??? CompoundStmt ForStmt
		fieldCount = 0

	}

	if signCharacter != 0 {
		status = rtlpWriteWideCharacter(context, signCharacter)
		if status != (0 as! XTSTATUS) {
			return status

		}


	}

	index = 0
	if writeExponent {
		if digitCount == 0 {
			digit = ???? resolve CharacterLiteral

		} else {
			digit = ???? resolve ArraySubscriptExpr
			??? CompoundStmt UnaryOperator

		}

		status = rtlpWriteWideCharacter(context, digit)
		if status != (0 as! XTSTATUS) {
			return status

		}

		if (formatProperties.Flags & 8192) and (precision != 0) {
			??? CompoundStmt UnaryOperator

		}

		if (precision != 0) or (formatProperties.Flags & 1024) {
			status = rtlpWriteWideCharacter(context, ???? resolve CharacterLiteral)
			if status != (0 as! XTSTATUS) {
				return status

			}


		}

		??? CompoundStmt ForStmt
		if formatProperties.Flags & 512 {
			exponentCharacter = ???? resolve CharacterLiteral

		} else {
			exponentCharacter = ???? resolve CharacterLiteral

		}

		status = rtlpWriteWideStringCustomValue(context, "%C%+0.2d", exponentCharacter, exponent)
		if status != (0 as! XTSTATUS) {
			return status

		}


	} else {
		if exponent >= 0 {
			currentExponent = exponent
			while currentExponent >= 0 {
				if index < digitCount {
					digit = ???? resolve ArraySubscriptExpr
					??? CompoundStmt UnaryOperator

				} else {
					digit = ???? resolve CharacterLiteral

				}

				status = rtlpWriteWideCharacter(context, digit)
				if status != (0 as! XTSTATUS) {
					return status

				}

				if (formatProperties.Flags & 8192) and (precision != 0) {
					??? CompoundStmt UnaryOperator

				}

				??? CompoundStmt UnaryOperator

			}


		} else {
			status = rtlpWriteWideCharacter(context, ???? resolve CharacterLiteral)
			if status != (0 as! XTSTATUS) {
				return status

			}

			currentExponent = -1

		}

		if (precision != 0) or (formatProperties.Flags & 1024) {
			status = rtlpWriteWideCharacter(context, ???? resolve CharacterLiteral)
			if status != (0 as! XTSTATUS) {
				return status

			}


		}

		??? CompoundStmt ForStmt

	}

	??? CompoundStmt ForStmt
	return (0 as! XTSTATUS)
}

/// Writes a wide string double value in the hexadecimal format to the destination provided by the print context.
/// 
/// @param Context
///        Supplies a pointer to the print context structure.
/// 
/// @param FormatProperties
///        Supplies a pointer to the print format properties structure, describing the style characteristics.
/// 
/// @param Double
///        Supplies the double/float value to write as a wide string in a hexadecimal format.
/// 
/// @return This routine returns a status code.
/// 
/// @since XT 1.0
fun rtlpWriteWideStringHexDoubleValue(context PRTL_PRINT_CONTEXT, formatProperties PRTL_PRINT_FORMAT_PROPERTIES, double DOUBLE) {
	var absoluteExponent LONG
	var exponent LONG
	var fieldCount LONG
	var index LONG
	var numberLength LONG
	var character WCHAR
	var digit WCHAR
	var exponentCharacter WCHAR
	var integerValue WCHAR
	var precision LONG
	var precisionIndex LONG
	var prefixIndex LONG
	var prefixSize LONG
	var halfWay ULONGLONG
	var roundingValue ULONGLONG
	var significand ULONGLONG
	var buffer WCHAR[15]
	var negativeValue BOOLEAN
	var parts LARGE_DOUBLE
	var prefix WCHAR[4]
	var status XTSTATUS
	negativeValue = fALSE
	Parts.DoublePart = double
	precision = formatProperties.Precision
	if double == ???? resolve FloatingLiteral {
		absoluteExponent = 0
		exponent = 0
		integerValue = ???? resolve CharacterLiteral
		significand = 0
		if precision == -1 {
			precision = 0

		}

		??? CompoundStmt ForStmt

	} else {
		if (Parts.u.HighPart & (9223372036854775808 >> 32)) != 0 {
			negativeValue = tRUE
			??? CompoundStmt CompoundAssignOperator

		}

		exponent = (Parts.u.HighPart & (9218868437227405312 >> 32)) >> (52 - 32)
		??? CompoundStmt CompoundAssignOperator
		absoluteExponent = exponent
		if absoluteExponent < 0 {
			??? CompoundStmt CompoundAssignOperator

		}

		significand = Parts.u.LowPart | ((Parts.u.HighPart & 1048575) as! ULONGLONG << (???? resolve UnaryExprOrTypeTraitExpr * 8))
		integerValue = ???? resolve CharacterLiteral
		if precision != -1 {
			halfWay = 1 << (52 - 1)
			roundingValue = halfWay
			if (precision * 4) > (???? resolve UnaryExprOrTypeTraitExpr * 8) {
				roundingValue = 0

			} else {
				roundingValue = roundingValue >> (precision * 4)

			}

			??? CompoundStmt CompoundAssignOperator
			if significand >= (1 << 52) {
				??? CompoundStmt CompoundAssignOperator
				??? CompoundStmt UnaryOperator

			}


		}

		??? CompoundStmt ForStmt
		if precision == -1 {
			precision = 13
			while (precision - 1 >= 0) and (???? resolve ArraySubscriptExpr == ???? resolve CharacterLiteral) {
				??? CompoundStmt UnaryOperator

			}


		}


	}

	prefixSize = 0
	if negativeValue {
		???? resolve ArraySubscriptExpr = ???? resolve CharacterLiteral
		??? CompoundStmt CompoundAssignOperator

	} else {
		??? CompoundStmt CompoundStmt
		if formatProperties.Flags & 2 {
			???? resolve ArraySubscriptExpr = ???? resolve CharacterLiteral
			??? CompoundStmt CompoundAssignOperator

		}


	}

	???? resolve ArraySubscriptExpr = ???? resolve CharacterLiteral
	???? resolve ArraySubscriptExpr = ???? resolve CharacterLiteral
	??? CompoundStmt CompoundAssignOperator
	numberLength = precision + 1
	if (formatProperties.Flags & 1024) or (precision != 0) {
		??? CompoundStmt CompoundAssignOperator

	}

	if formatProperties.Flags & 512 {
		exponentCharacter = ???? resolve CharacterLiteral

	} else {
		exponentCharacter = ???? resolve CharacterLiteral

	}

	??? CompoundStmt CompoundAssignOperator
	if absoluteExponent > 10 {
		??? CompoundStmt CompoundAssignOperator
		if absoluteExponent > 100 {
			??? CompoundStmt CompoundAssignOperator
			if absoluteExponent > 1000 {
				??? CompoundStmt CompoundAssignOperator

			}


		}


	}

	fieldCount = 0
	if numberLength + prefixSize < formatProperties.FieldWidth {
		fieldCount = formatProperties.FieldWidth - (numberLength + prefixSize)

	}

	if !(formatProperties.Flags & 4) or (formatProperties.Flags & 8) {
		if formatProperties.Flags & 8 {
			character = ???? resolve CharacterLiteral
			prefixIndex = 0
			while --prefixSize {
				status = rtlpWriteWideCharacter(context, ???? resolve ArraySubscriptExpr)
				if status != (0 as! XTSTATUS) {
					return status

				}

				??? CompoundStmt UnaryOperator

			}


		} else {
			character = ???? resolve CharacterLiteral

		}

		while fieldCount {
			status = rtlpWriteWideCharacter(context, character)
			if status != (0 as! XTSTATUS) {
				return status

			}

			??? CompoundStmt UnaryOperator

		}


	}

	??? CompoundStmt ForStmt
	status = rtlpWriteWideCharacter(context, integerValue)
	if status != (0 as! XTSTATUS) {
		return status

	}

	if (formatProperties.Flags & 1024) or (precision != 0) {
		status = rtlpWriteWideCharacter(context, ???? resolve CharacterLiteral)
		if status != (0 as! XTSTATUS) {
			return status

		}


	}

	??? CompoundStmt ForStmt
	status = rtlpWriteWideStringCustomValue(context, "%C%+d", exponentCharacter, exponent)
	if status != (0 as! XTSTATUS) {
		return status

	}

	while fieldCount {
		status = rtlpWriteWideCharacter(context, ???? resolve CharacterLiteral)
		if status != (0 as! XTSTATUS) {
			return status

		}

		??? CompoundStmt UnaryOperator

	}

	return (0 as! XTSTATUS)
}

/// Writes a wide string integer value to the destination provided by the print context.
/// 
/// @param Context
///        Supplies a pointer to the print context structure.
/// 
/// @param FormatProperties
///        Supplies a pointer to the print format properties structure, describing the style characteristics.
/// 
/// @param Integer
///        Supplies the integer value to write as a wide string.
/// 
/// @return This routine returns a status code.
/// 
/// @since XT 1.0
fun rtlpWriteWideStringIntegerValue(context PRTL_PRINT_CONTEXT, formatProperties PRTL_PRINT_FORMAT_PROPERTIES, integer ULONGLONG) {
	var bufferIndex LONG
	var fieldLength LONG
	var integerLength LONG
	var precisionLength LONG
	var prefixIndex LONG
	var prefixLength LONG
	var buffer WCHAR[25]
	var nextInteger ULONGLONG
	var remainder ULONGLONG
	var negative BOOLEAN
	var prefix WCHAR[4]
	var character WCHAR
	var status XTSTATUS
	integerLength = 0
	negative = fALSE
	if !(formatProperties.Flags & 256) {
		??? CompoundStmt SwitchStmt

	}

	if integer == 0 {
		??? CompoundStmt CompoundAssignOperator

	}

	if integer != 0 or formatProperties.Precision != 0 {
		if !(formatProperties.Flags & 256) and integer as! LONGLONG < 0 {
			negative = tRUE
			??? CompoundStmt CompoundAssignOperator

		}

		rtlZeroMemory(buffer, ???? resolve UnaryExprOrTypeTraitExpr)
		??? CompoundStmt DoStmt
		rtlReverseWideString(buffer, integerLength)

	}

	prefixLength = 0
	if !(formatProperties.Flags & 256) and negative {
		???? resolve ArraySubscriptExpr = ???? resolve CharacterLiteral
		??? CompoundStmt CompoundAssignOperator

	} else {
		??? CompoundStmt CompoundStmt
		if formatProperties.Flags & 2 {
			???? resolve ArraySubscriptExpr = ???? resolve CharacterLiteral
			??? CompoundStmt CompoundAssignOperator

		}


	}

	if formatProperties.Flags & 1024 {
		if formatProperties.Radix == 8 {
			if ???? resolve ArraySubscriptExpr != ???? resolve CharacterLiteral {
				???? resolve ArraySubscriptExpr = ???? resolve CharacterLiteral
				??? CompoundStmt CompoundAssignOperator

			}


		} else {
			??? CompoundStmt CompoundStmt

		}


	}

	precisionLength = 0
	if integerLength < formatProperties.Precision {
		precisionLength = formatProperties.Precision - integerLength

	}

	fieldLength = 0
	if integerLength + prefixLength + precisionLength < formatProperties.FieldWidth {
		fieldLength = formatProperties.FieldWidth - (integerLength + prefixLength + precisionLength)

	}

	if !(formatProperties.Flags & 4) or (formatProperties.Flags & 8) {
		character = ???? resolve CharacterLiteral
		if formatProperties.Flags & 8 {
			character = ???? resolve CharacterLiteral
			??? CompoundStmt ForStmt
			prefixLength = 0

		}

		while fieldLength > 0 {
			status = rtlpWriteWideCharacter(context, character)
			if status != (0 as! XTSTATUS) {
				return status

			}

			??? CompoundStmt UnaryOperator

		}


	}

	??? CompoundStmt ForStmt
	while precisionLength > 0 {
		status = rtlpWriteWideCharacter(context, ???? resolve CharacterLiteral)
		if status != (0 as! XTSTATUS) {
			return status

		}

		??? CompoundStmt UnaryOperator

	}

	??? CompoundStmt ForStmt
	while fieldLength > 0 {
		status = rtlpWriteWideCharacter(context, ???? resolve CharacterLiteral)
		if status != (0 as! XTSTATUS) {
			return status

		}

		??? CompoundStmt UnaryOperator

	}

	return (0 as! XTSTATUS)
}

/// Writes a string value to the destination provided by the print context.
/// 
/// @param Context
///        Supplies a pointer to the print context structure.
/// 
/// @param FormatProperties
///        Supplies a pointer to the print format properties structure, describing the style characteristics.
/// 
/// @param String
///        Supplies the string value to write as a wide string.
/// 
/// @param Character
///        Specifies whether the string value is expected to be a single character or not.
/// 
/// @return This routine returns a status code.
/// 
/// @since XT 1.0
fun rtlpWriteWideStringStringValue(context PRTL_PRINT_CONTEXT, formatProperties PRTL_PRINT_FORMAT_PROPERTIES, string PCHAR, stringLength SIZE_T) {
	var wideCharacter WCHAR[2]
	var paddingLength ULONG
	var status XTSTATUS
	if string == (0 as! PVOID) {
		string = ???? resolve StringLiteral
		stringLength = 6

	}

	if (formatProperties.Precision >= 0) and (stringLength > formatProperties.Precision) {
		stringLength = formatProperties.Precision

	}

	paddingLength = 0
	if formatProperties.FieldWidth > stringLength {
		paddingLength = formatProperties.FieldWidth - stringLength

	}

	if !(formatProperties.Flags & 4) {
		while paddingLength > 0 {
			status = rtlpWriteWideCharacter(context, ???? resolve CharacterLiteral)
			if status != (0 as! XTSTATUS) {
				return status

			}

			??? CompoundStmt UnaryOperator

		}


	}

	while stringLength {
		???? resolve ArraySubscriptExpr = *string
		???? resolve ArraySubscriptExpr = 0
		status = rtlpWriteWideCharacter(context, *wideCharacter)
		if status != (0 as! XTSTATUS) {
			return status

		}

		??? CompoundStmt UnaryOperator
		??? CompoundStmt UnaryOperator

	}

	while paddingLength > 0 {
		status = rtlpWriteWideCharacter(context, ???? resolve CharacterLiteral)
		if status != (0 as! XTSTATUS) {
			return status

		}

		??? CompoundStmt UnaryOperator

	}

	return (0 as! XTSTATUS)
}

/// Writes a wide string value to the destination provided by the print context.
/// 
/// @param Context
///        Supplies a pointer to the print context structure.
/// 
/// @param FormatProperties
///        Supplies a pointer to the print format properties structure, describing the style characteristics.
/// 
/// @param String
///        Supplies the wide string value to write.
/// 
/// @param Character
///        Specifies whether the string value is expected to be a single character or not.
/// 
/// @return This routine returns a status code.
/// 
/// @since XT 1.0
fun rtlpWriteWideStringValue(context PRTL_PRINT_CONTEXT, formatProperties PRTL_PRINT_FORMAT_PROPERTIES, string PWCHAR, stringLength SIZE_T) {
	var paddingLength ULONG
	var status XTSTATUS
	if string == (0 as! PVOID) {
		string = "(null)"
		stringLength = 6

	}

	if (formatProperties.Precision >= 0) and (stringLength > formatProperties.Precision) {
		stringLength = formatProperties.Precision

	}

	paddingLength = 0
	if formatProperties.FieldWidth > stringLength {
		paddingLength = formatProperties.FieldWidth - stringLength

	}

	if !(formatProperties.Flags & 4) {
		while paddingLength > 0 {
			status = rtlpWriteWideCharacter(context, ???? resolve CharacterLiteral)
			if status != (0 as! XTSTATUS) {
				return status

			}

			??? CompoundStmt UnaryOperator

		}


	}

	while stringLength != 0 {
		status = rtlpWriteWideCharacter(context, *string)
		if status != (0 as! XTSTATUS) {
			return status

		}

		??? CompoundStmt UnaryOperator
		??? CompoundStmt UnaryOperator

	}

	while paddingLength > 0 {
		status = rtlpWriteWideCharacter(context, ???? resolve CharacterLiteral)
		if status != (0 as! XTSTATUS) {
			return status

		}

		??? CompoundStmt UnaryOperator

	}

	return (0 as! XTSTATUS)
}
