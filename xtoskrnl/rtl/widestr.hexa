/// Compares at most specified number of characters of two C wide strings.
/// 
/// @param String1
///        Wide string to be compared.
/// 
/// @param String2
///        Wide string to be compared.
/// 
/// @param Length
///        Maximum number of characters to compare. If no limit set, it compares whole wide strings.
/// 
/// @return Integral value indicating the relationship between the wide strings.
/// 
/// @since XT 1.0
fun rtlCompareWideString(string1 Const PWCHAR, string2 Const PWCHAR, length SIZE_T) {
	var index SIZE_T
	[unknown clang ast] CompoundStmt ForStmt
	return 0
}

/// Compares at most specified number of characters of two C wide strings, while ignoring differences in case.
/// 
/// @param String1
///        Wide string to be compared.
/// 
/// @param String2
///        Wide string to be compared.
/// 
/// @param Length
///        Maximum number of characters to compare. If no limit set, it compares whole wide strings.
/// 
/// @return Integral value indicating the relationship between the wide strings.
/// 
/// @since XT 1.0
fun rtlCompareWideStringInsensitive(string1 Const PWCHAR, string2 Const PWCHAR, length SIZE_T) {
	var character1 WCHAR
	var character2 WCHAR
	var index ULONG = 0
	while string1[index] != 0/* "\u0000" */ and string2[index] != 0/* "\u0000" */ {
		if index != 0 and index == length {
			break
		}

		character1 = string1[index]
		character2 = string2[index]
		if string1[index] >= 65/* "A" */ and string1[index] <= 90/* "Z" */ {
			character1 = string1[index] - 65/* "A" */ + 97/* "a" */

		}

		if string2[index] >= 65/* "A" */ and string2[index] <= 90/* "Z" */ {
			character2 = string2[index] - 65/* "A" */ + 97/* "a" */

		}

		if character1 != character2 {
			return (character1 > character2) ? 1 : -1

		}

		index++
	}

	return 0
}

/// Appends a copy of the source wide string to the end of the destination wide string.
/// 
/// @param Destination
///        Supplies a pointer to the null-terminated wide string to append to.
/// 
/// @param Source
///        Supplies a pointer to the null-terminated wide string to copy from.
/// 
/// @param Count
///        Sets a maximum number of wide characters to copy. If no limit set, appends whole wide string.
/// 
/// @return This routine returns a copy of a destination wide string.
/// 
/// @since XT 1.0
fun rtlConcatenateWideString(destination PWCHAR, source PWCHAR, count SIZE_T) {
	var destString PWCHAR = destination
	while destination[0] {
		destination++
	}

	if count > 0 {
		[unknown clang ast] CompoundStmt DoStmt
		destination[0] = 0/* "\u0000" */

	} else {
		while (++destination[0] = ++source[0]) != 0 {

		}


	}

	return destString
}

/// Copies a wide string from a buffer into another buffer, ensuring that the destination string is NULL-terminated.
/// 
/// @param Destination
///        Supplies a pointer to the destination buffer.
/// 
/// @param Source
///        Supplies a pointer to the source buffer.
/// 
/// @param Length
///        Supplies the length of the wide string to copy.
/// 
/// @return This routine does not return any value.
/// 
/// @since XT 1.0
fun rtlCopyWideString(destination PWCHAR, source Const PWCHAR, length ULONG) {
	var index ULONG
	[unknown clang ast] CompoundStmt ForStmt
	destination[index] = 0/* "\u0000" */
}

/// Formats a wide string according to the given printf-alike format string.
/// 
/// @param Context
///        Supplies a pointer to the print context structure.
/// 
/// @param Format
///        Supplies a pointer to the printf-alike format string.
/// 
/// @param ArgumentList
///        Supplies a list of arguments to the format string.
/// 
/// @return This routine returns a status code.
/// 
/// @since XT 1.0
fun rtlFormatWideString(context PRTL_PRINT_CONTEXT, format PCWSTR, argumentList VA_LIST) {
	var localArgumentList VA_LIST
	var status XTSTATUS
	var index ULONG
	if context == (0 as! PVOID) or context.writeWideCharacter == (0 as! PVOID) {
		return fALSE

	}

	if format == (0 as! PVOID) {
		format = "(null)"

	}

	__builtin_va_copy(localArgumentList, argumentList)
	index = 0
	while format[index] != 0/* "\u0000" */ {
		if format[index] == 37/* "%" */ {
			status = rtlpFormatWideStringArgumentSpecifier(context, format, localArgumentList, index)

		} else {
			status = rtlpWriteWideCharacter(context, format[index])
			index++
		}

		if status != (0 as! XTSTATUS) {
			return status

		}


	}

	__builtin_va_end(localArgumentList)
	return (0 as! XTSTATUS)
}

/// Reverses a characters order in a wide string. It modifies the original, input variable.
/// 
/// @param String
///        Supplies a pointer to the wide string to reverse.
/// 
/// @param Length
///        Supplies the length of the wide string to reverse.
/// 
/// @return This routine does not return any value.
/// 
/// @since XT 1.0
fun rtlReverseWideString(string PWCHAR, length ULONG) {
	var tempChar WCHAR
	var index ULONG
	[unknown clang ast] CompoundStmt ForStmt
}

/// Finds the next token in a null-terminated wide string.
/// 
/// @param String
///        Pointer to the null-terminated wide string to tokenize.
/// 
/// @param Delimiter
///        Pointer to the null-terminated wide string identifying delimiters.
/// 
/// @param SavePtr
///        Pointer to an object used to store routine internal state.
/// 
/// @return Pointer to the beginning of the next token or NULL if there are no more tokens.
/// 
/// @since: XT 1.0
fun rtlTokenizeWideString(string PWCHAR, delimiter Const PWCHAR, savePtr PWCHAR *) {
	var span PWCHAR
	var token PWCHAR
	var char WCHAR
	var spanChar WCHAR
	if string == (0 as! PVOID) and (string = savePtr[0]) == (0 as! PVOID) {
		return (0 as! PVOID)

	}

	char = ++string[0]
	if char == 0/* "\u0000" */ {
		savePtr[0] = (0 as! PVOID)
		return (0 as! PVOID)

	}

	token = string - 1
	[unknown clang ast] CompoundStmt ForStmt
}

/// Removes certain characters from a beginning of the wide string.
/// 
/// @param String
///        Pointer to the null-terminated wide string to be trimmed.
/// 
/// @return This routine returns a pointer to the left-trimmed wide string.
/// 
/// @since XT 1.0
fun rtlTrimLeftWideString(string Const PWCHAR) {
	var start PWCHAR
	start = string
	while start[0] == 32/* " " */ or start[0] == 10/* "\n" */ or start[0] == 9/* "\t" */ or start[0] == 13/* "\r" */ or start[0] == 11/* "\u000b" */ or start[0] == 12/* "\f" */ {
		start++
	}

	return start
}

/// Removes certain characters from the end of the wide string.
/// 
/// @param String
///        Pointer to the null-terminated wide string to be trimmed.
/// 
/// @return This routine returns a pointer to the right-trimmed wide string.
/// 
/// @since XT 1.0
fun rtlTrimRightWideString(string Const PWCHAR) {
	var end PWCHAR
	end = string + rtlWideStringLength(string, 0)
	while (end != string) and (end[0] == 32/* " " */ or end[0] == 10/* "\n" */ or end[0] == 9/* "\t" */ or end[0] == 13/* "\r" */ or end[0] == 11/* "\u000b" */ or end[0] == 12/* "\f" */) {
		end--
	}

	end[0] = 0
	return string
}

/// Removes certain characters from the beginning and the end of the wide string.
/// 
/// @param String
///        Pointer to the null-terminated wide string to be trimmed.
/// 
/// @return This routine returns a pointer to the trimmed wide string.
/// 
/// @since XT 1.0
fun rtlTrimWideString(string Const PWCHAR) {
	return rtlTrimLeftWideString(rtlTrimRightWideString(string))
}

/// Calculates the length of a given wide string.
/// 
/// @param String
///        Pointer to the null-terminated wide string to be examined.
/// 
/// @param MaxLength
///        Maximum number of wide characters to examine. If no limit set, it examines whole string.
/// 
/// @return The length of the null-terminated wide string.
/// 
/// @since: XT 1.0
fun rtlWideStringLength(string Const PWCHAR, maxLength SIZE_T) {
	var length SIZE_T
	if string == (0 as! PVOID) {
		return 0

	}

	[unknown clang ast] CompoundStmt ForStmt
	return length
}

/// Formats a wide string according to the given printf-alike format string and a list of arguments.
/// 
/// @param Context
///        Supplies a pointer to the print context structure.
/// 
/// @param Format
///        Supplies a pointer to the printf-alike format string.
/// 
/// @param ArgumentList
///        Supplies a list of arguments to the format string.
/// 
/// @param Index
///        Supplies a pointer to the position of the current format specifier, that will be advanced beyond the specifier.
/// 
/// @return This routine returns a status code.
/// 
/// @since XT 1.0
fun rtlpFormatWideStringArgumentSpecifier(context PRTL_PRINT_CONTEXT, format PCWSTR, argumentList PVA_LIST, index PULONG) {
	let formatProperties = new ByValue<RTL_PRINT_FORMAT_PROPERTIES>()

	let unicodeStrArg = new ByValue<PUNICODE_STRING>()

	var specifier WCHAR
	var wideCharArg WCHAR
	let ansiStrArg = new ByValue<PANSI_STRING>()

	var specifierValue LONGLONG
	var argumentsCopy VA_LIST
	var floatArg LARGE_DOUBLE
	var formatIndex PCWSTR
	var argPosition ULONG
	var wideStrArg PWCHAR
	var intArg ULONGLONG
	var status XTSTATUS
	let guidArg = new ByValue<PGUID>()

	var strArg PCHAR
	var charArg CHAR
	formatIndex = format + index[0] + 1
	argPosition = 0
	rtlZeroMemory(formatProperties, sizeOf<Unsigned long long>())
	FormatProperties.IntegerSize = sizeOf<Unsigned long long>()
	FormatProperties.Precision = -1
	__builtin_va_copy(argumentsCopy, argumentList[0])
	if (formatIndex[0] >= 49/* "1" */) and (formatIndex[0] <= 57/* "9" */) {
		specifierValue = rtlpGetWideStringSpecifierValue(formatIndex as! PWSTR *)
		if formatIndex[0] == 36/* "$" */ {
			argPosition = specifierValue as! ULONG
			formatIndex++
		} else {
			FormatProperties.FieldWidth = specifierValue as! ULONG

		}


	}

	while tRUE {
		if formatIndex[0] == 39/* "'" */ {
			FormatProperties.Flags |= 16384

		} else {
			[unknown clang ast] CompoundStmt CompoundStmt
			if formatIndex[0] == 32/* " " */ {
				FormatProperties.Flags |= 2

			} else {
				[unknown clang ast] CompoundStmt CompoundStmt
				if formatIndex[0] == 35/* "#" */ {
					FormatProperties.Flags |= 1024

				} else {
					[unknown clang ast] CompoundStmt CompoundStmt
					[unknown clang ast] CompoundStmt CompoundStmt

				}


			}


		}

		formatIndex++
	}

	if FormatProperties.Flags & 4 {
		FormatProperties.Flags &= ~8

	}

	if FormatProperties.Flags & 1 {
		FormatProperties.Flags &= ~2

	}

	if formatIndex[0] == 42/* "*" */ {
		formatIndex++		FormatProperties.FieldWidth = (((sizeOf<Unsigned long long>() < sizeOf<Unsigned long long>())) ? ([unknown clang ast] resolve VAArgExpr) as! INT : ([unknown clang ast] resolve VAArgExpr) as! INT)

	} else {
		[unknown clang ast] CompoundStmt CompoundStmt

	}

	if FormatProperties.FieldWidth < 0 {
		FormatProperties.Flags |= 4
		FormatProperties.FieldWidth *= -1

	}

	if formatIndex[0] == 46/* "." */ {
		formatIndex++		if formatIndex[0] == 42/* "*" */ {
			formatIndex++			FormatProperties.Precision = (((sizeOf<Unsigned long long>() < sizeOf<Unsigned long long>())) ? ([unknown clang ast] resolve VAArgExpr) as! INT : ([unknown clang ast] resolve VAArgExpr) as! INT)

		} else {
			[unknown clang ast] CompoundStmt CompoundStmt
			[unknown clang ast] CompoundStmt CompoundStmt

		}


	}

	if FormatProperties.Precision < 0 {
		FormatProperties.Precision = -1

	}

	specifier = formatIndex[0]
	[unknown clang ast] CompoundStmt SwitchStmt
	specifier = ++formatIndex[0]
	if FormatProperties.Flags & 64 {
		if specifier == 99/* "c" */ {
			specifier = 67/* "C" */

		} else {
			[unknown clang ast] CompoundStmt CompoundStmt

		}


	}

	FormatProperties.Flags |= 256
	[unknown clang ast] CompoundStmt SwitchStmt
	if FormatProperties.VariableType == unknown {
		status = rtlpWriteWideStringValue(context, formatProperties, wideCharArg, 1)

	}

	if FormatProperties.VariableType == boolean {
		if argPosition != 0 {
			intArg = rtlpGetWideStringArgument(argumentsCopy, argPosition, FormatProperties.IntegerSize)

		} else {
			intArg = (((sizeOf<Unsigned long long>() < sizeOf<Unsigned long long>())) ? ([unknown clang ast] resolve VAArgExpr) as! ULONGLONG : ([unknown clang ast] resolve VAArgExpr) as! ULONGLONG)

		}

		if FormatProperties.Flags & 512 {
			wideStrArg = (intArg) ? "TRUE" : "FALSE"

		} else {
			wideStrArg = (intArg) ? "true" : "false"

		}

		status = rtlpWriteWideStringValue(context, formatProperties, wideStrArg, rtlWideStringLength(wideStrArg, 0))

	} else {
		[unknown clang ast] CompoundStmt CompoundStmt
		if FormatProperties.VariableType == char {
			if argPosition != 0 {
				charArg = rtlpGetWideStringArgument(argumentsCopy, argPosition, sizeOf<Unsigned long long>()) as! UCHAR

			} else {
				charArg = (((sizeOf<Unsigned long long>() < sizeOf<Unsigned long long>())) ? ([unknown clang ast] resolve VAArgExpr) as! INT : ([unknown clang ast] resolve VAArgExpr) as! INT)

			}

			status = rtlpWriteWideStringStringValue(context, formatProperties, charArg, 1)

		} else {
			[unknown clang ast] CompoundStmt CompoundStmt
			if FormatProperties.VariableType == float {
				if argPosition != 0 {
					FloatArg.QuadPart = rtlpGetWideStringArgument(argumentsCopy, argPosition, sizeOf<Unsigned long long>())

				} else {
					if FormatProperties.Flags & 32 {
						FloatArg.DoublePart = (((sizeOf<Unsigned long long>() < sizeOf<Unsigned long long>())) ? ([unknown clang ast] resolve VAArgExpr) as! LDOUBLE : ([unknown clang ast] resolve VAArgExpr) as! LDOUBLE)

					} else {
						FloatArg.DoublePart = (((sizeOf<Unsigned long long>() < sizeOf<Unsigned long long>())) ? ([unknown clang ast] resolve VAArgExpr) as! DOUBLE : ([unknown clang ast] resolve VAArgExpr) as! DOUBLE)

					}


				}

				status = rtlpWriteWideStringDoubleValue(context, formatProperties, FloatArg.DoublePart)

			} else {
				[unknown clang ast] CompoundStmt CompoundStmt
				if FormatProperties.VariableType == string {
					if argPosition != 0 {
						intArg = rtlpGetWideStringArgument(argumentsCopy, argPosition, sizeOf<Unsigned long long>())
						strArg = intArg as! UINT_PTR as! PCHAR

					} else {
						strArg = (((sizeOf<Unsigned long long>() < sizeOf<Unsigned long long>())) ? ([unknown clang ast] resolve VAArgExpr) as! PCHAR : ([unknown clang ast] resolve VAArgExpr) as! PCHAR)

					}

					status = rtlpWriteWideStringStringValue(context, formatProperties, strArg, rtlStringLength(strArg, 0))

				} else {
					[unknown clang ast] CompoundStmt CompoundStmt
					if FormatProperties.VariableType == ansiString {
						if argPosition != 0 {
							intArg = rtlpGetWideStringArgument(argumentsCopy, argPosition, sizeOf<Unsigned long long>())
							ansiStrArg = intArg as! UINT_PTR as! PANSI_STRING

						} else {
							ansiStrArg = (((sizeOf<Unsigned long long>() < sizeOf<Unsigned long long>())) ? ([unknown clang ast] resolve VAArgExpr) as! PANSI_STRING : ([unknown clang ast] resolve VAArgExpr) as! PANSI_STRING)

						}

						if ansiStrArg != (0 as! PVOID) {
							status = rtlpWriteWideStringStringValue(context, formatProperties, ansiStrArg.buffer, ansiStrArg.length)

						}


					} else {
						[unknown clang ast] CompoundStmt CompoundStmt

					}


				}


			}


		}


	}

	__builtin_va_end(argumentsCopy)
	index[0] += (formatIndex as! UINT_PTR - (format + index[0]) as! UINT_PTR) / sizeOf<Unsigned long long>()
	return status
}

/// Gets the positional argument by scanning the argument list.
/// 
/// @param ArgumentList
///        Supplies a pointer to the argument list.
/// 
/// @param ArgumentNumber
///        Supplies the argument number.
/// 
/// @param ArgumentSize
///        Supplies the expected size of the argument.
fun rtlpGetWideStringArgument(argumentList PVA_LIST, argumentNumber ULONG, argumentSize LONG) {
	var argumentsCopy VA_LIST
	var value ULONGLONG
	var index ULONG
	__builtin_va_copy(argumentsCopy, argumentList[0])
	[unknown clang ast] CompoundStmt ForStmt
	value = 0
	[unknown clang ast] CompoundStmt SwitchStmt
	__builtin_va_end(argumentsCopy)
	return value
}

/// Gets the specifier integer value from the wide string advancing the pointer.
/// 
/// @param Format
///        Supplies a pointer to the wide string format, at integer value position.
/// 
/// @return This routine returns a specifier integer value read from wide string format, or zero if no valid value found.
/// 
/// @since XT 1.0
fun rtlpGetWideStringSpecifierValue(format PWCHAR *) {
	var count ULONG
	var fmt PWCHAR
	fmt = format[0]
	count = 0
	[unknown clang ast] CompoundStmt ForStmt
	return 0
}

/// Writes a wide character to the destination provided by the print context.
/// 
/// @param Context
///        Supplies a pointer to the print context structure.
/// 
/// @param Character
///        Supplies the wide character to write.
/// 
/// @return This routine returns a status code.
/// 
/// @since XT 1.0
fun rtlpWriteWideCharacter(context PRTL_PRINT_CONTEXT, character WCHAR) {
	var status XTSTATUS
	status = context.writeWideCharacter(character)
	context.charactersWritten++	return status
}

/// Writes a wide string custom-formatted value to the destination provided by the print context.
/// 
/// @param Context
///        Supplies a pointer to the print context structure.
/// 
/// @param Format
///        Supplies a pointer to the printf-alike format string.
/// 
/// @param ...
///        Depending on the format string, this routine might expect a sequence of additional arguments.
/// 
/// @return This routine returns a status code.
/// 
/// @since XT 1.0
fun rtlpWriteWideStringCustomValue(context PRTL_PRINT_CONTEXT, format PCWSTR) {
	var arguments VA_LIST
	var status XTSTATUS
	__builtin_va_start(arguments, format)
	status = rtlFormatWideString(context, format, arguments)
	__builtin_va_end(arguments)
	return status
}

fun rtlpWriteWideStringDoubleValue(context PRTL_PRINT_CONTEXT, formatProperties PRTL_PRINT_FORMAT_PROPERTIES, value DOUBLE) {
	var currentExponent LONG
	var digitCount LONG
	var exponent LONG
	var precision LONG
	var precisionIndex LONG
	var significantDigits LONG
	var character WCHAR
	var digit WCHAR
	var exponentCharacter WCHAR
	var signCharacter WCHAR
	var fieldCount ULONG
	var fieldIndex ULONG
	var index ULONG
	var numberLength ULONG
	var buffer WCHAR[15]
	var negativeValue BOOLEAN
	var writeExponent BOOLEAN
	var roundingAmount DOUBLE
	var tenPower DOUBLE
	var nonNumberString PWCHAR
	var parts LARGE_DOUBLE
	var status XTSTATUS
	negativeValue = fALSE
	numberLength = 0
	Parts.DoublePart = value
	precision = formatProperties.precision
	signCharacter = 0
	if precision == -1 {
		precision = 6

	}

	if (formatProperties.flags & 8192) and (precision == 0) {
		precision = 1

	}

	if rtlInfiniteDouble(value) {
		if rtlNanDouble(value) {
			if formatProperties.flags & 512 {
				nonNumberString = "#NAN"

			} else {
				nonNumberString = "#nan"

			}


		} else {
			if formatProperties.flags & 512 {
				nonNumberString = "#INF"

			} else {
				nonNumberString = "#inf"

			}

			if value < 0 {
				negativeValue = tRUE

			}


		}

		index = 0
		if negativeValue != fALSE {
			buffer[index] = 45/* "-" */
			index++
		} else {
			[unknown clang ast] CompoundStmt CompoundStmt
			if formatProperties.flags & 2 {
				buffer[index] = 32/* " " */
				index++
			}


		}

		rtlCopyWideString(buffer + index, nonNumberString, sizeOf<Unsigned long long>() - index)
		return rtlpWriteWideStringValue(context, formatProperties, buffer, rtlWideStringLength(buffer, 0))

	}

	if formatProperties.radix == 16 {
		return rtlpWriteWideStringHexDoubleValue(context, formatProperties, value)

	}

	if (Parts.u.highPart & (9223372036854775808 >> 32)) != 0 {
		value *= -1
		negativeValue = tRUE

	}

	exponent = rtlGetBaseExponent(value, tenPower)
	roundingAmount = 0.5
	writeExponent = (formatProperties.flags & 4096)
	if (writeExponent == fALSE) and !(formatProperties.flags & 2048) {
		if (exponent < -4) or (exponent >= precision) {
			writeExponent = tRUE

		}


	}

	digitCount = 0
	if value != 0 {
		if (writeExponent != fALSE) or (formatProperties.flags & 8192) {
			roundingAmount /= tenPower
			if formatProperties.flags & 8192 {
				roundingAmount *= 10

			}


		}

		[unknown clang ast] CompoundStmt ForStmt
		value += roundingAmount
		value *= tenPower
		if value as! LONG > 9 {
			value *= 0.10000000000000001
			exponent += 1

		}

		while (value != 0) and (digitCount < 15) {
			buffer[digitCount] = value as! LONG + 48/* "0" */
			digitCount += 1
			value = (value - value as! LONG as! Double) * 10

		}

		if formatProperties.flags & 8192 {
			if precision > 0 {
				if digitCount > precision {
					digitCount = precision

				}


			}


		}

		while (digitCount > 1) and (buffer[digitCount - 1] == 48/* "0" */) {
			digitCount -= 1

		}


	}

	if negativeValue {
		signCharacter = 45/* "-" */

	} else {
		[unknown clang ast] CompoundStmt CompoundStmt
		if formatProperties.flags & 2 {
			signCharacter = 32/* " " */

		}


	}

	significantDigits = digitCount
	if formatProperties.flags & 8192 {
		if significantDigits > precision {
			significantDigits = precision

		} else {
			[unknown clang ast] CompoundStmt CompoundStmt

		}


	}

	numberLength = precision
	if formatProperties.flags & 1024 {
		numberLength += 1

	} else {
		[unknown clang ast] CompoundStmt CompoundStmt
		if precision != 0 {
			numberLength += 1

		}


	}

	if writeExponent {
		numberLength += 4
		if !(formatProperties.flags & 8192) {
			numberLength += 1

		}

		if exponent < 0 {
			if exponent <= -100 {
				numberLength += 1
				if exponent <= -1000 {
					numberLength += 1

				}


			}


		} else {
			if exponent >= 100 {
				numberLength += 1
				if exponent >= 1000 {
					numberLength += 1

				}


			}


		}


	} else {
		if exponent >= 0 {
			if !(formatProperties.flags & 8192) {
				numberLength += exponent + 1

			}


		} else {
			numberLength += 1
			if formatProperties.flags & 8192 {
				precision += (-exponent) - 1
				numberLength += (-exponent) - 1

			}


		}


	}

	if signCharacter != 0 {
		numberLength += 1

	}

	fieldCount = 0
	if numberLength < formatProperties.fieldWidth {
		fieldCount = formatProperties.fieldWidth - numberLength

	}

	if (formatProperties.flags & 4) or (formatProperties.flags & 8) {
		if signCharacter != 0 {
			status = rtlpWriteWideCharacter(context, signCharacter)
			if status != (0 as! XTSTATUS) {
				return status

			}


		}

		signCharacter = 0

	}

	if !(formatProperties.flags & 4) or (formatProperties.flags & 8) {
		if formatProperties.flags & 8 {
			character = 48/* "0" */

		} else {
			character = 32/* " " */

		}

		[unknown clang ast] CompoundStmt ForStmt
		fieldCount = 0

	}

	if signCharacter != 0 {
		status = rtlpWriteWideCharacter(context, signCharacter)
		if status != (0 as! XTSTATUS) {
			return status

		}


	}

	index = 0
	if writeExponent {
		if digitCount == 0 {
			digit = 48/* "0" */

		} else {
			digit = buffer[index]
			index++
		}

		status = rtlpWriteWideCharacter(context, digit)
		if status != (0 as! XTSTATUS) {
			return status

		}

		if (formatProperties.flags & 8192) and (precision != 0) {
			precision--
		}

		if (precision != 0) or (formatProperties.flags & 1024) {
			status = rtlpWriteWideCharacter(context, 46/* "." */)
			if status != (0 as! XTSTATUS) {
				return status

			}


		}

		[unknown clang ast] CompoundStmt ForStmt
		if formatProperties.flags & 512 {
			exponentCharacter = 69/* "E" */

		} else {
			exponentCharacter = 101/* "e" */

		}

		status = rtlpWriteWideStringCustomValue(context, "%C%+0.2d", exponentCharacter, exponent)
		if status != (0 as! XTSTATUS) {
			return status

		}


	} else {
		if exponent >= 0 {
			currentExponent = exponent
			while currentExponent >= 0 {
				if index < digitCount {
					digit = buffer[index]
					index++
				} else {
					digit = 48/* "0" */

				}

				status = rtlpWriteWideCharacter(context, digit)
				if status != (0 as! XTSTATUS) {
					return status

				}

				if (formatProperties.flags & 8192) and (precision != 0) {
					precision--
				}

				currentExponent--
			}


		} else {
			status = rtlpWriteWideCharacter(context, 48/* "0" */)
			if status != (0 as! XTSTATUS) {
				return status

			}

			currentExponent = -1

		}

		if (precision != 0) or (formatProperties.flags & 1024) {
			status = rtlpWriteWideCharacter(context, 46/* "." */)
			if status != (0 as! XTSTATUS) {
				return status

			}


		}

		[unknown clang ast] CompoundStmt ForStmt

	}

	[unknown clang ast] CompoundStmt ForStmt
	return (0 as! XTSTATUS)
}

/// Writes a wide string double value in the hexadecimal format to the destination provided by the print context.
/// 
/// @param Context
///        Supplies a pointer to the print context structure.
/// 
/// @param FormatProperties
///        Supplies a pointer to the print format properties structure, describing the style characteristics.
/// 
/// @param Double
///        Supplies the double/float value to write as a wide string in a hexadecimal format.
/// 
/// @return This routine returns a status code.
/// 
/// @since XT 1.0
fun rtlpWriteWideStringHexDoubleValue(context PRTL_PRINT_CONTEXT, formatProperties PRTL_PRINT_FORMAT_PROPERTIES, double DOUBLE) {
	var absoluteExponent LONG
	var exponent LONG
	var fieldCount LONG
	var index LONG
	var numberLength LONG
	var character WCHAR
	var digit WCHAR
	var exponentCharacter WCHAR
	var integerValue WCHAR
	var precision LONG
	var precisionIndex LONG
	var prefixIndex LONG
	var prefixSize LONG
	var halfWay ULONGLONG
	var roundingValue ULONGLONG
	var significand ULONGLONG
	var buffer WCHAR[15]
	var negativeValue BOOLEAN
	var parts LARGE_DOUBLE
	var prefix WCHAR[4]
	var status XTSTATUS
	negativeValue = fALSE
	Parts.DoublePart = double
	precision = formatProperties.precision
	if double == 0 {
		absoluteExponent = 0
		exponent = 0
		integerValue = 48/* "0" */
		significand = 0
		if precision == -1 {
			precision = 0

		}

		[unknown clang ast] CompoundStmt ForStmt

	} else {
		if (Parts.u.highPart & (9223372036854775808 >> 32)) != 0 {
			negativeValue = tRUE
			Parts.DoublePart *= -1

		}

		exponent = (Parts.u.highPart & (9218868437227405312 >> 32)) >> (52 - 32)
		exponent -= 1023
		absoluteExponent = exponent
		if absoluteExponent < 0 {
			absoluteExponent *= -1

		}

		significand = Parts.u.lowPart | ((Parts.u.highPart & 1048575) as! ULONGLONG << (sizeOf<Unsigned long long>() * 8))
		integerValue = 49/* "1" */
		if precision != -1 {
			halfWay = 1 << (52 - 1)
			roundingValue = halfWay
			if (precision * 4) > (sizeOf<Unsigned long long>() * 8) {
				roundingValue = 0

			} else {
				roundingValue = roundingValue >> (precision * 4)

			}

			significand += roundingValue
			if significand >= (1 << 52) {
				significand -= (1 << 52)
				integerValue++
			}


		}

		[unknown clang ast] CompoundStmt ForStmt
		if precision == -1 {
			precision = 13
			while (precision - 1 >= 0) and (buffer[precision - 1] == 48/* "0" */) {
				precision--
			}


		}


	}

	prefixSize = 0
	if negativeValue {
		prefix[prefixSize] = 45/* "-" */
		prefixSize += 1

	} else {
		[unknown clang ast] CompoundStmt CompoundStmt
		if formatProperties.flags & 2 {
			prefix[prefixSize] = 32/* " " */
			prefixSize += 1

		}


	}

	prefix[prefixSize] = 48/* "0" */
	prefix[prefixSize + 1] = 120/* "x" */
	prefixSize += 2
	numberLength = precision + 1
	if (formatProperties.flags & 1024) or (precision != 0) {
		numberLength += 1

	}

	if formatProperties.flags & 512 {
		exponentCharacter = 80/* "P" */

	} else {
		exponentCharacter = 112/* "p" */

	}

	numberLength += 3
	if absoluteExponent > 10 {
		numberLength += 1
		if absoluteExponent > 100 {
			numberLength += 1
			if absoluteExponent > 1000 {
				numberLength += 1

			}


		}


	}

	fieldCount = 0
	if numberLength + prefixSize < formatProperties.fieldWidth {
		fieldCount = formatProperties.fieldWidth - (numberLength + prefixSize)

	}

	if !(formatProperties.flags & 4) or (formatProperties.flags & 8) {
		if formatProperties.flags & 8 {
			character = 48/* "0" */
			prefixIndex = 0
			while --prefixSize {
				status = rtlpWriteWideCharacter(context, prefix[prefixIndex])
				if status != (0 as! XTSTATUS) {
					return status

				}

				prefixIndex++
			}


		} else {
			character = 32/* " " */

		}

		while fieldCount {
			status = rtlpWriteWideCharacter(context, character)
			if status != (0 as! XTSTATUS) {
				return status

			}

			fieldCount--
		}


	}

	[unknown clang ast] CompoundStmt ForStmt
	status = rtlpWriteWideCharacter(context, integerValue)
	if status != (0 as! XTSTATUS) {
		return status

	}

	if (formatProperties.flags & 1024) or (precision != 0) {
		status = rtlpWriteWideCharacter(context, 46/* "." */)
		if status != (0 as! XTSTATUS) {
			return status

		}


	}

	[unknown clang ast] CompoundStmt ForStmt
	status = rtlpWriteWideStringCustomValue(context, "%C%+d", exponentCharacter, exponent)
	if status != (0 as! XTSTATUS) {
		return status

	}

	while fieldCount {
		status = rtlpWriteWideCharacter(context, 32/* " " */)
		if status != (0 as! XTSTATUS) {
			return status

		}

		fieldCount--
	}

	return (0 as! XTSTATUS)
}

/// Writes a wide string integer value to the destination provided by the print context.
/// 
/// @param Context
///        Supplies a pointer to the print context structure.
/// 
/// @param FormatProperties
///        Supplies a pointer to the print format properties structure, describing the style characteristics.
/// 
/// @param Integer
///        Supplies the integer value to write as a wide string.
/// 
/// @return This routine returns a status code.
/// 
/// @since XT 1.0
fun rtlpWriteWideStringIntegerValue(context PRTL_PRINT_CONTEXT, formatProperties PRTL_PRINT_FORMAT_PROPERTIES, integer ULONGLONG) {
	var bufferIndex LONG
	var fieldLength LONG
	var integerLength LONG
	var precisionLength LONG
	var prefixIndex LONG
	var prefixLength LONG
	var buffer WCHAR[25]
	var nextInteger ULONGLONG
	var remainder ULONGLONG
	var negative BOOLEAN
	var prefix WCHAR[4]
	var character WCHAR
	var status XTSTATUS
	integerLength = 0
	negative = fALSE
	if !(formatProperties.flags & 256) {
		[unknown clang ast] CompoundStmt SwitchStmt

	}

	if integer == 0 {
		formatProperties.flags &= ~1024

	}

	if integer != 0 or formatProperties.precision != 0 {
		if !(formatProperties.flags & 256) and integer as! LONGLONG < 0 {
			negative = tRUE
			integer *= -1

		}

		rtlZeroMemory(buffer, sizeOf<Unsigned long long>())
		[unknown clang ast] CompoundStmt DoStmt
		rtlReverseWideString(buffer, integerLength)

	}

	prefixLength = 0
	if !(formatProperties.flags & 256) and negative {
		prefix[prefixLength] = 45/* "-" */
		prefixLength += 1

	} else {
		[unknown clang ast] CompoundStmt CompoundStmt
		if formatProperties.flags & 2 {
			prefix[prefixLength] = 32/* " " */
			prefixLength += 1

		}


	}

	if formatProperties.flags & 1024 {
		if formatProperties.radix == 8 {
			if buffer[0] != 48/* "0" */ {
				prefix[prefixLength] = 48/* "0" */
				prefixLength += 1

			}


		} else {
			[unknown clang ast] CompoundStmt CompoundStmt

		}


	}

	precisionLength = 0
	if integerLength < formatProperties.precision {
		precisionLength = formatProperties.precision - integerLength

	}

	fieldLength = 0
	if integerLength + prefixLength + precisionLength < formatProperties.fieldWidth {
		fieldLength = formatProperties.fieldWidth - (integerLength + prefixLength + precisionLength)

	}

	if !(formatProperties.flags & 4) or (formatProperties.flags & 8) {
		character = 32/* " " */
		if formatProperties.flags & 8 {
			character = 48/* "0" */
			[unknown clang ast] CompoundStmt ForStmt
			prefixLength = 0

		}

		while fieldLength > 0 {
			status = rtlpWriteWideCharacter(context, character)
			if status != (0 as! XTSTATUS) {
				return status

			}

			fieldLength--
		}


	}

	[unknown clang ast] CompoundStmt ForStmt
	while precisionLength > 0 {
		status = rtlpWriteWideCharacter(context, 48/* "0" */)
		if status != (0 as! XTSTATUS) {
			return status

		}

		precisionLength--
	}

	[unknown clang ast] CompoundStmt ForStmt
	while fieldLength > 0 {
		status = rtlpWriteWideCharacter(context, 32/* " " */)
		if status != (0 as! XTSTATUS) {
			return status

		}

		fieldLength--
	}

	return (0 as! XTSTATUS)
}

/// Writes a string value to the destination provided by the print context.
/// 
/// @param Context
///        Supplies a pointer to the print context structure.
/// 
/// @param FormatProperties
///        Supplies a pointer to the print format properties structure, describing the style characteristics.
/// 
/// @param String
///        Supplies the string value to write as a wide string.
/// 
/// @param Character
///        Specifies whether the string value is expected to be a single character or not.
/// 
/// @return This routine returns a status code.
/// 
/// @since XT 1.0
fun rtlpWriteWideStringStringValue(context PRTL_PRINT_CONTEXT, formatProperties PRTL_PRINT_FORMAT_PROPERTIES, string PCHAR, stringLength SIZE_T) {
	var wideCharacter WCHAR[2]
	var paddingLength ULONG
	var status XTSTATUS
	if string == (0 as! PVOID) {
		string = "(null)"
		stringLength = 6

	}

	if (formatProperties.precision >= 0) and (stringLength > formatProperties.precision) {
		stringLength = formatProperties.precision

	}

	paddingLength = 0
	if formatProperties.fieldWidth > stringLength {
		paddingLength = formatProperties.fieldWidth - stringLength

	}

	if !(formatProperties.flags & 4) {
		while paddingLength > 0 {
			status = rtlpWriteWideCharacter(context, 32/* " " */)
			if status != (0 as! XTSTATUS) {
				return status

			}

			paddingLength--
		}


	}

	while stringLength {
		wideCharacter[0] = string[0]
		wideCharacter[1] = 0
		status = rtlpWriteWideCharacter(context, wideCharacter[0])
		if status != (0 as! XTSTATUS) {
			return status

		}

		stringLength--		string++
	}

	while paddingLength > 0 {
		status = rtlpWriteWideCharacter(context, 32/* " " */)
		if status != (0 as! XTSTATUS) {
			return status

		}

		paddingLength--
	}

	return (0 as! XTSTATUS)
}

/// Writes a wide string value to the destination provided by the print context.
/// 
/// @param Context
///        Supplies a pointer to the print context structure.
/// 
/// @param FormatProperties
///        Supplies a pointer to the print format properties structure, describing the style characteristics.
/// 
/// @param String
///        Supplies the wide string value to write.
/// 
/// @param Character
///        Specifies whether the string value is expected to be a single character or not.
/// 
/// @return This routine returns a status code.
/// 
/// @since XT 1.0
fun rtlpWriteWideStringValue(context PRTL_PRINT_CONTEXT, formatProperties PRTL_PRINT_FORMAT_PROPERTIES, string PWCHAR, stringLength SIZE_T) {
	var paddingLength ULONG
	var status XTSTATUS
	if string == (0 as! PVOID) {
		string = "(null)"
		stringLength = 6

	}

	if (formatProperties.precision >= 0) and (stringLength > formatProperties.precision) {
		stringLength = formatProperties.precision

	}

	paddingLength = 0
	if formatProperties.fieldWidth > stringLength {
		paddingLength = formatProperties.fieldWidth - stringLength

	}

	if !(formatProperties.flags & 4) {
		while paddingLength > 0 {
			status = rtlpWriteWideCharacter(context, 32/* " " */)
			if status != (0 as! XTSTATUS) {
				return status

			}

			paddingLength--
		}


	}

	while stringLength != 0 {
		status = rtlpWriteWideCharacter(context, string[0])
		if status != (0 as! XTSTATUS) {
			return status

		}

		stringLength--		string++
	}

	while paddingLength > 0 {
		status = rtlpWriteWideCharacter(context, 32/* " " */)
		if status != (0 as! XTSTATUS) {
			return status

		}

		paddingLength--
	}

	return (0 as! XTSTATUS)
}
