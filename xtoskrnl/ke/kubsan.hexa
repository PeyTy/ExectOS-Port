// Hexa 2024 from clang 15.0.3
/// Checks whether handled UBSAN error should be reported.
/// 
/// @param Location
///        Supplies a pointer to the UBSAN location descriptor.
/// 
/// @return This routine returns TRUE if UBSAN error should be reported, or FALSE otherwise.
/// 
/// @since XT 1.0
fun kepCheckUbsanReport(location PKUBSAN_SOURCE_LOCATION) {
	return !kepUbsanActiveFrame
}

/// Enters UBSAN frame and marks it as active.
/// 
/// @param Location
///        Supplies a pointer to the UBSAN location descriptor.
/// 
/// @param Reason
///        Supplies a pointer to the reason of the UBSAN failure.
/// 
/// @return This routine does not return any value.
/// 
/// @since XT 1.0
fun kepEnterUbsanFrame(location PKUBSAN_SOURCE_LOCATION, reason PCCHAR) {
	kepUbsanActiveFrame = tRUE
	if keDbgPrint {
		??? CompoundStmt ImplicitCastExpr
		??? CompoundStmt ImplicitCastExpr
		??? CompoundStmt ImplicitCastExpr
		??? CompoundStmt ImplicitCastExpr
		??? CompoundStmt ImplicitCastExpr
		??? CompoundStmt ImplicitCastExpr

	}

	??? CompoundStmt NullStmt
}

/// Gets signed value from UBSAN.
/// 
/// @param Type
///        Supplies a pointer to the UBSAN type descriptor.
/// 
/// @param Value
///        Supplies a pointer to the UBSAN value.
/// 
/// @return This routine returns a 64-bit signed integer.
/// 
/// @since XT 1.0
fun kepGetSignedUbsanValue(type PKUBSAN_TYPE_DESCRIPTOR, value PVOID) {
	var bitWidth ULONG
	var extraBits ULONG
	var longValue ULONG_PTR
	bitWidth = 1 << (type.TypeInfo >> 1)
	if bitWidth <= ???? resolve UnaryExprOrTypeTraitExpr * 8 {
		extraBits = ???? resolve UnaryExprOrTypeTraitExpr * 8 - bitWidth
		longValue = value as! ULONG_PTR
		return (longValue as! LONGLONG) << extraBits >> extraBits

	}

	return *value as! PLONGLONG
}

/// Gets a string representation of the UBSAN type kind.
/// 
/// @param TypeCheckKind
///        Supplies a UBSAN type kind as a numeric value.
/// 
/// @return This routine returns a string representation of the UBSAN type.
/// 
/// @since XT 1.0
fun kepGetUbsanTypeKind(typeCheckKind UCHAR) {
	??? CompoundStmt SwitchStmt
}

/// Gets unsigned value from UBSAN.
/// 
/// @param Type
///        Supplies a pointer to the UBSAN type descriptor.
/// 
/// @param Value
///        Supplies a pointer to the UBSAN value.
/// 
/// @return This routine returns a 64-bit unsigned integer.
/// 
/// @since XT 1.0
fun kepGetUnsignedUbsanValue(type PKUBSAN_TYPE_DESCRIPTOR, value PVOID) {
	var bitWidth ULONG
	bitWidth = 1 << (type.TypeInfo >> 1)
	if bitWidth <= ???? resolve UnaryExprOrTypeTraitExpr * 8 {
		return value as! ULONG_PTR

	}

	return *value as! PULONGLONG
}

/// Handles the division overflow error reported by UBSAN.
/// 
/// @param Data
///        Supplies a pointer to the UBSAN overflow data.
/// 
/// @param Lhs
///        Supplies LHS operand.
/// 
/// @param Rhs
///        Supplies RHS operand.
/// 
/// @return This routine does not return any value.
/// 
/// @since XT 1.0
fun kepHandleUbsanDivisionOverflow(data PKUBSAN_OVERFLOW_DATA, lhs PVOID, rhs PVOID) {
	if !kepCheckUbsanReport(data.Location) {
		return ??

	}

	kepEnterUbsanFrame(data.Location, ???? resolve StringLiteral)
	if (data.Type.TypeInfo & 1) and (kepGetSignedUbsanValue(data.Type, rhs) == -1) {
		if keDbgPrint {
			??? CompoundStmt ImplicitCastExpr
			??? CompoundStmt ImplicitCastExpr
			??? CompoundStmt ImplicitCastExpr

		}

		??? CompoundStmt NullStmt

	} else {
		if keDbgPrint {
			??? CompoundStmt ImplicitCastExpr
			??? CompoundStmt ImplicitCastExpr

		}

		??? CompoundStmt NullStmt

	}

	kepLeaveUbsanFrame()
}

/// Handles the float cast overflow error reported by UBSAN.
/// 
/// @param Data
///        Supplies a pointer to the UBSAN float cast overflow data.
/// 
/// @param Lhs
///        Supplies LHS operand.
/// 
/// @param Rhs
///        Supplies RHS operand.
/// 
/// @return This routine does not return any value.
/// 
/// @since XT 1.0
fun kepHandleUbsanFloatCastOverflow(data PKUBSAN_FLOAT_CAST_OVERFLOW_DATA, lhs ULONG_PTR, rhs ULONG_PTR) {
	if !kepCheckUbsanReport(data.Location) {
		return ??

	}

	kepEnterUbsanFrame(data.Location, ???? resolve StringLiteral)
	if keDbgPrint {
		??? CompoundStmt ImplicitCastExpr
		??? CompoundStmt ImplicitCastExpr
		??? CompoundStmt ImplicitCastExpr
		??? CompoundStmt ImplicitCastExpr

	}

	??? CompoundStmt NullStmt
	kepLeaveUbsanFrame()
}

/// Handles the function type mismatch error reported by UBSAN.
/// 
/// @param Data
///        Supplies a pointer to the UBSAN function type mismatch data.
/// 
/// @param Pointer
///        Supplies pointer operand.
/// 
/// @return This routine does not return any value.
/// 
/// @since XT 1.0
fun kepHandleUbsanFunctionTypeMismatch(data PKUBSAN_FUNCTION_TYPE_MISMATCH_DATA, pointer ULONG_PTR) {
	if !kepCheckUbsanReport(data.Location) {
		return ??

	}

	kepEnterUbsanFrame(data.Location, ???? resolve StringLiteral)
	if keDbgPrint {
		??? CompoundStmt ImplicitCastExpr
		??? CompoundStmt ImplicitCastExpr
		??? CompoundStmt CStyleCastExpr
		??? CompoundStmt ImplicitCastExpr

	}

	??? CompoundStmt NullStmt
	kepLeaveUbsanFrame()
}

/// Handles the integer overflow error reported by UBSAN.
/// 
/// @param Data
///        Supplies a pointer to the UBSAN overflow data.
/// 
/// @param Lhs
///        Supplies LHS operand.
/// 
/// @param Rhs
///        Supplies RHS operand.
/// 
/// @return This routine does not return any value.
/// 
/// @since XT 1.0
fun kepHandleUbsanIntegerOverflow(data PKUBSAN_OVERFLOW_DATA, lhs ULONG_PTR, rhs ULONG_PTR) {
	if !kepCheckUbsanReport(data.Location) {
		return ??

	}

	kepEnterUbsanFrame(data.Location, ???? resolve StringLiteral)
	if keDbgPrint {
		??? CompoundStmt ImplicitCastExpr
		??? CompoundStmt ImplicitCastExpr
		??? CompoundStmt ImplicitCastExpr

	}

	??? CompoundStmt NullStmt
	kepLeaveUbsanFrame()
}

/// Handles the invalid builtin error reported by UBSAN.
/// 
/// @param Data
///        Supplies a pointer to the UBSAN invalid builtin data.
/// 
/// @return This routine does not return any value.
/// 
/// @since XT 1.0
fun kepHandleUbsanInvalidBuiltin(data PKUBSAN_INVALID_BUILTIN_DATA) {
	if !kepCheckUbsanReport(data.Location) {
		return ??

	}

	kepEnterUbsanFrame(data.Location, ???? resolve StringLiteral)
	if data.Kind == 0 or data.Kind == 1 {
		if keDbgPrint {
			??? CompoundStmt ImplicitCastExpr
			??? CompoundStmt ImplicitCastExpr

		}

		??? CompoundStmt NullStmt

	} else {
		if keDbgPrint {
			??? CompoundStmt ImplicitCastExpr
			??? CompoundStmt ImplicitCastExpr
			??? CompoundStmt ImplicitCastExpr

		}

		??? CompoundStmt NullStmt

	}

	kepLeaveUbsanFrame()
}

/// Handles the misaligned access error reported by UBSAN.
/// 
/// @param Data
///        Supplies a pointer to the UBSAN type mismatch data.
/// 
/// @param Pointer
///        Supplies a pointer operand.
/// 
/// @return This routine does not return any value.
/// 
/// @since XT 1.0
fun kepHandleUbsanMisalignedAccess(data PKUBSAN_TYPE_MISMATCH_DATA, pointer ULONG_PTR) {
	if !kepCheckUbsanReport(data.Location) {
		return ??

	}

	kepEnterUbsanFrame(data.Location, ???? resolve StringLiteral)
	if keDbgPrint {
		??? CompoundStmt ImplicitCastExpr
		??? CompoundStmt ImplicitCastExpr
		kepGetUbsanTypeKind(data.TypeCheckKind)
		??? CompoundStmt CStyleCastExpr
		??? CompoundStmt ImplicitCastExpr
		??? CompoundStmt ImplicitCastExpr

	}

	??? CompoundStmt NullStmt
	kepLeaveUbsanFrame()
}

/// Handles the negate overflow error reported by UBSAN.
/// 
/// @param Data
///        Supplies a pointer to the UBSAN overflow data.
/// 
/// @param OldValue
///        Supplies old value.
/// 
/// @return This routine does not return any value.
/// 
/// @since XT 1.0
fun kepHandleUbsanNegateOverflow(data PKUBSAN_OVERFLOW_DATA, oldValue ULONG_PTR) {
	if !kepCheckUbsanReport(data.Location) {
		return ??

	}

	kepEnterUbsanFrame(data.Location, ???? resolve StringLiteral)
	if keDbgPrint {
		??? CompoundStmt ImplicitCastExpr
		??? CompoundStmt ImplicitCastExpr
		??? CompoundStmt ImplicitCastExpr
		??? CompoundStmt ImplicitCastExpr

	}

	??? CompoundStmt NullStmt
	kepLeaveUbsanFrame()
}

/// Handles the NULL pointer dereference error reported by UBSAN.
/// 
/// @param Data
///        Supplies a pointer to the UBSAN type mismatch data.
/// 
/// @param Pointer
///        Supplies a pointer operand.
/// 
/// @return This routine does not return any value.
/// 
/// @since XT 1.0
fun kepHandleUbsanNullPointerDereference(data PKUBSAN_TYPE_MISMATCH_DATA) {
	if !kepCheckUbsanReport(data.Location) {
		return ??

	}

	kepEnterUbsanFrame(data.Location, ???? resolve StringLiteral)
	if keDbgPrint {
		??? CompoundStmt ImplicitCastExpr
		??? CompoundStmt ImplicitCastExpr
		kepGetUbsanTypeKind(data.TypeCheckKind)
		??? CompoundStmt ImplicitCastExpr

	}

	??? CompoundStmt NullStmt
	kepLeaveUbsanFrame()
}

/// Handles the object size mismatch error reported by UBSAN.
/// 
/// @param Data
///        Supplies a pointer to the UBSAN type mismatch data.
/// 
/// @param Pointer
///        Supplies a pointer operand.
/// 
/// @return This routine does not return any value.
/// 
/// @since XT 1.0
fun kepHandleUbsanObjectSizeMismatch(data PKUBSAN_TYPE_MISMATCH_DATA, pointer ULONG_PTR) {
	if !kepCheckUbsanReport(data.Location) {
		return ??

	}

	kepEnterUbsanFrame(data.Location, ???? resolve StringLiteral)
	if keDbgPrint {
		??? CompoundStmt ImplicitCastExpr
		??? CompoundStmt ImplicitCastExpr
		kepGetUbsanTypeKind(data.TypeCheckKind)
		??? CompoundStmt CStyleCastExpr
		??? CompoundStmt ImplicitCastExpr

	}

	??? CompoundStmt NullStmt
	kepLeaveUbsanFrame()
}

/// Handles the out of bounds error reported by UBSAN.
/// 
/// @param Data
///        Supplies a pointer to the UBSAN out of bounds data.
/// 
/// @param Index
///        Supplies an index operand.
/// 
/// @return This routine does not return any value.
/// 
/// @since XT 1.0
fun kepHandleUbsanOutOfBounds(data PKUBSAN_OUT_OF_BOUNDS_DATA, index ULONG_PTR) {
	if !kepCheckUbsanReport(data.Location) {
		return ??

	}

	kepEnterUbsanFrame(data.Location, ???? resolve StringLiteral)
	if keDbgPrint {
		??? CompoundStmt ImplicitCastExpr
		??? CompoundStmt ImplicitCastExpr
		??? CompoundStmt ImplicitCastExpr

	}

	??? CompoundStmt NullStmt
	kepLeaveUbsanFrame()
}

/// Handles the pointer overflow error reported by UBSAN.
/// 
/// @param Data
///        Supplies a pointer to the UBSAN overflow data.
/// 
/// @param Lhs
///        Supplies LHS operand.
/// 
/// @param Rhs
///        Supplies RHS operand.
/// 
/// @return This routine does not return any value.
/// 
/// @since XT 1.0
fun kepHandleUbsanPointerOverflow(data PKUBSAN_OVERFLOW_DATA, lhs ULONG_PTR, rhs ULONG_PTR) {
	if !kepCheckUbsanReport(data.Location) {
		return ??

	}

	kepEnterUbsanFrame(data.Location, ???? resolve StringLiteral)
	if keDbgPrint {
		??? CompoundStmt ImplicitCastExpr
		??? CompoundStmt ImplicitCastExpr
		??? CompoundStmt ConditionalOperator
		??? CompoundStmt CStyleCastExpr
		??? CompoundStmt CStyleCastExpr

	}

	??? CompoundStmt NullStmt
	kepLeaveUbsanFrame()
}

/// Handles the shift out of bounds error reported by UBSAN.
/// 
/// @param Data
///        Supplies a pointer to the UBSAN shift out of bounds data.
/// 
/// @param Lhs
///        Supplies LHS operand.
/// 
/// @param Rhs
///        Supplies RHS operand.
/// 
/// @return This routine does not return any value.
/// 
/// @since XT 1.0
fun kepHandleUbsanShiftOutOfBounds(data PKUBSAN_SHIFT_OUT_OF_BOUNDS_DATA, lhs ULONG_PTR, rhs ULONG_PTR) {
	var lhsBitWidth ULONG
	if !kepCheckUbsanReport(data.Location) {
		return ??

	}

	kepEnterUbsanFrame(data.Location, ???? resolve StringLiteral)
	lhsBitWidth = 1 << (data.LhsType.TypeInfo >> 1)
	if (data.RhsType.TypeInfo & 1) and (kepGetSignedUbsanValue(data.RhsType, rhs as! PVOID) < 0) {
		if keDbgPrint {
			??? CompoundStmt ImplicitCastExpr
			??? CompoundStmt ImplicitCastExpr
			kepGetSignedUbsanValue(data.RhsType, rhs as! PVOID)

		}

		??? CompoundStmt NullStmt

	} else {
		??? CompoundStmt CompoundStmt
		if kepGetUnsignedUbsanValue(data.RhsType, rhs as! PVOID) >= lhsBitWidth {
			if keDbgPrint {
				??? CompoundStmt ImplicitCastExpr
				??? CompoundStmt ImplicitCastExpr
				kepGetUnsignedUbsanValue(data.RhsType, rhs as! PVOID)
				??? CompoundStmt ImplicitCastExpr
				??? CompoundStmt ImplicitCastExpr

			}

			??? CompoundStmt NullStmt

		} else {
			if keDbgPrint {
				??? CompoundStmt ImplicitCastExpr
				??? CompoundStmt ImplicitCastExpr
				kepGetSignedUbsanValue(data.LhsType, lhs as! PVOID)
				kepGetSignedUbsanValue(data.RhsType, rhs as! PVOID)
				??? CompoundStmt ImplicitCastExpr

			}

			??? CompoundStmt NullStmt

		}


	}

	kepLeaveUbsanFrame()
}

/// Handles the type mismatch error reported by UBSAN.
/// 
/// @param Data
///        Supplies a pointer to the UBSAN type mismatch data.
/// 
/// @param Pointer
///        Supplies a pointer operand.
/// 
/// @return This routine does not return any value.
/// 
/// @since XT 1.0
fun kepHandleUbsanTypeMismatch(data PKUBSAN_TYPE_MISMATCH_DATA, pointer ULONG_PTR) {
	if !pointer {
		kepHandleUbsanNullPointerDereference(data)

	} else {
		??? CompoundStmt CompoundStmt
		??? CompoundStmt CompoundStmt

	}

}

/// Leaves the UBSAN frame by marking it as inactive.
/// 
/// @return This routine does not return any value.
/// 
/// @since XT 1.0
fun kepLeaveUbsanFrame() {
	kepUbsanActiveFrame = fALSE
}

/// Handles the addition overflow error. This is internal routine implementing ABI defined by CLANG UBSAN.
/// 
/// @param Data
///        Supplies a pointer to the UBSAN overflow data.
/// 
/// @param Lhs
///        Supplies LHS operand.
/// 
/// @param Rhs
///        Supplies RHS operand.
/// 
/// @return This routine does not return any value.
/// 
/// @since XT 1.0
/// 
/// @see https://github.com/llvm/llvm-project/blob/release/18.x/clang/lib/CodeGen/CodeGenFunction.h#L113
fun __ubsan_handle_add_overflow(data PKUBSAN_OVERFLOW_DATA, lhs ULONG_PTR, rhs ULONG_PTR) {
	kepHandleUbsanIntegerOverflow(data, lhs, rhs)
}

/// Handles the division overflow error. This is internal routine implementing ABI defined by CLANG UBSAN.
/// 
/// @param Data
///        Supplies a pointer to the UBSAN overflow data.
/// 
/// @param Lhs
///        Supplies LHS operand.
/// 
/// @param Rhs
///        Supplies RHS operand.
/// 
/// @return This routine does not return any value.
/// 
/// @since XT 1.0
/// 
/// @see https://github.com/llvm/llvm-project/blob/release/18.x/clang/lib/CodeGen/CodeGenFunction.h#L113
fun __ubsan_handle_divrem_overflow(data PKUBSAN_OVERFLOW_DATA, lhs PVOID, rhs PVOID) {
	kepHandleUbsanDivisionOverflow(data, lhs, rhs)
}

/// Handles the float cast overflow error. This is internal routine implementing ABI defined by CLANG UBSAN.
/// 
/// @param Data
///        Supplies a pointer to the UBSAN float cast overflow data.
/// 
/// @param Lhs
///        Supplies LHS operand.
/// 
/// @param Rhs
///        Supplies RHS operand.
/// 
/// @return This routine does not return any value.
/// 
/// @since XT 1.0
/// 
/// @see https://github.com/llvm/llvm-project/blob/release/18.x/clang/lib/CodeGen/CodeGenFunction.h#L113
fun __ubsan_handle_float_cast_overflow(data PKUBSAN_FLOAT_CAST_OVERFLOW_DATA, lhs ULONG_PTR, rhs ULONG_PTR) {
	kepHandleUbsanFloatCastOverflow(data, lhs, rhs)
}

/// Handles the function type mismatch error. This is internal routine implementing ABI defined by CLANG UBSAN.
/// 
/// @param Data
///        Supplies a pointer to the UBSAN function type mismatch data.
/// 
/// @param Pointer
///        Supplies pointer operand.
/// 
/// @return This routine does not return any value.
/// 
/// @since XT 1.0
/// 
/// @see https://github.com/llvm/llvm-project/blob/release/18.x/clang/lib/CodeGen/CodeGenFunction.h#L113
fun __ubsan_handle_function_type_mismatch(data PKUBSAN_FUNCTION_TYPE_MISMATCH_DATA, pointer ULONG_PTR) {
	kepHandleUbsanFunctionTypeMismatch(data, pointer)
}

/// Handles the invalid builtin error. This is internal routine implementing ABI defined by CLANG UBSAN.
/// 
/// @param Data
///        Supplies a pointer to the UBSAN invalid builtin data.
/// 
/// @return This routine does not return any value.
/// 
/// @since XT 1.0
/// 
/// @see https://github.com/llvm/llvm-project/blob/release/18.x/clang/lib/CodeGen/CodeGenFunction.h#L113
fun __ubsan_handle_invalid_builtin(data PKUBSAN_INVALID_BUILTIN_DATA) {
	kepHandleUbsanInvalidBuiltin(data)
}

/// Handles the multiplication overflow error. This is internal routine implementing ABI defined by CLANG UBSAN.
/// 
/// @param Data
///        Supplies a pointer to the UBSAN overflow data.
/// 
/// @param Lhs
///        Supplies LHS operand.
/// 
/// @param Rhs
///        Supplies RHS operand.
/// 
/// @return This routine does not return any value.
/// 
/// @since XT 1.0
/// 
/// @see https://github.com/llvm/llvm-project/blob/release/18.x/clang/lib/CodeGen/CodeGenFunction.h#L113
fun __ubsan_handle_mul_overflow(data PKUBSAN_OVERFLOW_DATA, lhs ULONG_PTR, rhs ULONG_PTR) {
	kepHandleUbsanIntegerOverflow(data, lhs, rhs)
}

/// Handles the negate overflow error. This is internal routine implementing ABI defined by CLANG UBSAN.
/// 
/// @param Data
///        Supplies a pointer to the UBSAN overflow data.
/// 
/// @param OldValue
///        Supplies old value.
/// 
/// @return This routine does not return any value.
/// 
/// @since XT 1.0
/// 
/// @see https://github.com/llvm/llvm-project/blob/release/18.x/clang/lib/CodeGen/CodeGenFunction.h#L113
fun __ubsan_handle_negate_overflow(data PKUBSAN_OVERFLOW_DATA, oldValue ULONG_PTR) {
	kepHandleUbsanNegateOverflow(data, oldValue)
}

/// Handles the out of bounds error. This is internal routine implementing ABI defined by CLANG UBSAN.
/// 
/// @param Data
///        Supplies a pointer to the UBSAN out of bounds data.
/// 
/// @param Index
///        Supplies an index operand.
/// 
/// @return This routine does not return any value.
/// 
/// @since XT 1.0
/// 
/// @see https://github.com/llvm/llvm-project/blob/release/18.x/clang/lib/CodeGen/CodeGenFunction.h#L113
fun __ubsan_handle_out_of_bounds(data PKUBSAN_OUT_OF_BOUNDS_DATA, index ULONG_PTR) {
	kepHandleUbsanOutOfBounds(data, index)
}

/// Handles the pointer overflow error. This is internal routine implementing ABI defined by CLANG UBSAN.
/// 
/// @param Data
///        Supplies a pointer to the UBSAN overflow data.
/// 
/// @param Lhs
///        Supplies LHS operand.
/// 
/// @param Rhs
///        Supplies RHS operand.
/// 
/// @return This routine does not return any value.
/// 
/// @since XT 1.0
/// 
/// @see https://github.com/llvm/llvm-project/blob/release/18.x/clang/lib/CodeGen/CodeGenFunction.h#L113
fun __ubsan_handle_pointer_overflow(data PKUBSAN_OVERFLOW_DATA, lhs ULONG_PTR, rhs ULONG_PTR) {
	kepHandleUbsanPointerOverflow(data, lhs, rhs)
}

/// Handles the shift out of bounds error. This is internal routine implementing ABI defined by CLANG UBSAN.
/// 
/// @param Data
///        Supplies a pointer to the UBSAN shift out of bounds data.
/// 
/// @param Lhs
///        Supplies LHS operand.
/// 
/// @param Rhs
///        Supplies RHS operand.
/// 
/// @return This routine does not return any value.
/// 
/// @since XT 1.0
/// 
/// @see https://github.com/llvm/llvm-project/blob/release/18.x/clang/lib/CodeGen/CodeGenFunction.h#L113
fun __ubsan_handle_shift_out_of_bounds(data PKUBSAN_SHIFT_OUT_OF_BOUNDS_DATA, lhs ULONG_PTR, rhs ULONG_PTR) {
	kepHandleUbsanShiftOutOfBounds(data, lhs, rhs)
}

/// Handles the subtraction overflow error. This is internal routine implementing ABI defined by CLANG UBSAN.
/// 
/// @param Data
///        Supplies a pointer to the UBSAN overflow data.
/// 
/// @param Lhs
///        Supplies LHS operand.
/// 
/// @param Rhs
///        Supplies RHS operand.
/// 
/// @return This routine does not return any value.
/// 
/// @since XT 1.0
/// 
/// @see https://github.com/llvm/llvm-project/blob/release/18.x/clang/lib/CodeGen/CodeGenFunction.h#L113
fun __ubsan_handle_sub_overflow(data PKUBSAN_OVERFLOW_DATA, lhs ULONG_PTR, rhs ULONG_PTR) {
	kepHandleUbsanIntegerOverflow(data, lhs, rhs)
}

/// Handles the type mismatch error. This is internal routine implementing ABI defined by CLANG UBSAN.
/// 
/// @param Data
///        Supplies a pointer to the UBSAN type mismatch data.
/// 
/// @param Pointer
///        Supplies a pointer operand.
/// 
/// @return This routine does not return any value.
/// 
/// @since XT 1.0
/// 
/// @see https://github.com/llvm/llvm-project/blob/release/18.x/clang/lib/CodeGen/CodeGenFunction.h#L113
fun __ubsan_handle_type_mismatch(data PKUBSAN_TYPE_MISMATCH_DATA, pointer ULONG_PTR) {
	kepHandleUbsanTypeMismatch(data, pointer)
}

/// Handles the type mismatch error. This is internal routine implementing ABI defined by CLANG UBSAN.
/// 
/// @param Data
///        Supplies a pointer to the UBSAN type mismatch data.
/// 
/// @param Pointer
///        Supplies a pointer operand.
/// 
/// @return This routine does not return any value.
/// 
/// @since XT 1.0
/// 
/// @see https://github.com/llvm/llvm-project/blob/release/18.x/clang/lib/CodeGen/CodeGenFunction.h#L113
fun __ubsan_handle_type_mismatch_v1(data PKUBSAN_TYPE_MISMATCH_DATA_V1, pointer ULONG_PTR) {
	let mismatchData = new ByValue<KUBSAN_TYPE_MISMATCH_DATA>()

	kepHandleUbsanTypeMismatch(mismatchData, pointer)
}
